// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package eventv1

import (
	fmt "fmt"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_QuerySubnetsRequest protoreflect.MessageDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QuerySubnetsRequest = File_hetu_event_v1_query_proto.Messages().ByName("QuerySubnetsRequest")
}

var _ protoreflect.Message = (*fastReflection_QuerySubnetsRequest)(nil)

type fastReflection_QuerySubnetsRequest QuerySubnetsRequest

func (x *QuerySubnetsRequest) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QuerySubnetsRequest)(x)
}

func (x *QuerySubnetsRequest) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QuerySubnetsRequest_messageType fastReflection_QuerySubnetsRequest_messageType
var _ protoreflect.MessageType = fastReflection_QuerySubnetsRequest_messageType{}

type fastReflection_QuerySubnetsRequest_messageType struct{}

func (x fastReflection_QuerySubnetsRequest_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QuerySubnetsRequest)(nil)
}
func (x fastReflection_QuerySubnetsRequest_messageType) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetsRequest)
}
func (x fastReflection_QuerySubnetsRequest_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetsRequest
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QuerySubnetsRequest) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetsRequest
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QuerySubnetsRequest) Type() protoreflect.MessageType {
	return _fastReflection_QuerySubnetsRequest_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QuerySubnetsRequest) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetsRequest)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QuerySubnetsRequest) Interface() protoreflect.ProtoMessage {
	return (*QuerySubnetsRequest)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QuerySubnetsRequest) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QuerySubnetsRequest) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsRequest does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetsRequest) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsRequest does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QuerySubnetsRequest) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsRequest does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetsRequest) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsRequest does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetsRequest) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsRequest does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QuerySubnetsRequest) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsRequest does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QuerySubnetsRequest) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QuerySubnetsRequest", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QuerySubnetsRequest) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetsRequest) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QuerySubnetsRequest) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QuerySubnetsRequest) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QuerySubnetsRequest)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetsRequest)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetsRequest)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetsRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_QuerySubnetsResponse_1_list)(nil)

type _QuerySubnetsResponse_1_list struct {
	list *[]*SubnetInfo
}

func (x *_QuerySubnetsResponse_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_QuerySubnetsResponse_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_QuerySubnetsResponse_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*SubnetInfo)
	(*x.list)[i] = concreteValue
}

func (x *_QuerySubnetsResponse_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*SubnetInfo)
	*x.list = append(*x.list, concreteValue)
}

func (x *_QuerySubnetsResponse_1_list) AppendMutable() protoreflect.Value {
	v := new(SubnetInfo)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_QuerySubnetsResponse_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_QuerySubnetsResponse_1_list) NewElement() protoreflect.Value {
	v := new(SubnetInfo)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_QuerySubnetsResponse_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_QuerySubnetsResponse         protoreflect.MessageDescriptor
	fd_QuerySubnetsResponse_subnets protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QuerySubnetsResponse = File_hetu_event_v1_query_proto.Messages().ByName("QuerySubnetsResponse")
	fd_QuerySubnetsResponse_subnets = md_QuerySubnetsResponse.Fields().ByName("subnets")
}

var _ protoreflect.Message = (*fastReflection_QuerySubnetsResponse)(nil)

type fastReflection_QuerySubnetsResponse QuerySubnetsResponse

func (x *QuerySubnetsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QuerySubnetsResponse)(x)
}

func (x *QuerySubnetsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QuerySubnetsResponse_messageType fastReflection_QuerySubnetsResponse_messageType
var _ protoreflect.MessageType = fastReflection_QuerySubnetsResponse_messageType{}

type fastReflection_QuerySubnetsResponse_messageType struct{}

func (x fastReflection_QuerySubnetsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QuerySubnetsResponse)(nil)
}
func (x fastReflection_QuerySubnetsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetsResponse)
}
func (x fastReflection_QuerySubnetsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QuerySubnetsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QuerySubnetsResponse) Type() protoreflect.MessageType {
	return _fastReflection_QuerySubnetsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QuerySubnetsResponse) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QuerySubnetsResponse) Interface() protoreflect.ProtoMessage {
	return (*QuerySubnetsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QuerySubnetsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Subnets) != 0 {
		value := protoreflect.ValueOfList(&_QuerySubnetsResponse_1_list{list: &x.Subnets})
		if !f(fd_QuerySubnetsResponse_subnets, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QuerySubnetsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetsResponse.subnets":
		return len(x.Subnets) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetsResponse.subnets":
		x.Subnets = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QuerySubnetsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.QuerySubnetsResponse.subnets":
		if len(x.Subnets) == 0 {
			return protoreflect.ValueOfList(&_QuerySubnetsResponse_1_list{})
		}
		listValue := &_QuerySubnetsResponse_1_list{list: &x.Subnets}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetsResponse.subnets":
		lv := value.List()
		clv := lv.(*_QuerySubnetsResponse_1_list)
		x.Subnets = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetsResponse.subnets":
		if x.Subnets == nil {
			x.Subnets = []*SubnetInfo{}
		}
		value := &_QuerySubnetsResponse_1_list{list: &x.Subnets}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QuerySubnetsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetsResponse.subnets":
		list := []*SubnetInfo{}
		return protoreflect.ValueOfList(&_QuerySubnetsResponse_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QuerySubnetsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QuerySubnetsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QuerySubnetsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QuerySubnetsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QuerySubnetsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QuerySubnetsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Subnets) > 0 {
			for _, e := range x.Subnets {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Subnets) > 0 {
			for iNdEx := len(x.Subnets) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Subnets[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Subnets = append(x.Subnets, &SubnetInfo{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Subnets[len(x.Subnets)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QuerySubnetRequest        protoreflect.MessageDescriptor
	fd_QuerySubnetRequest_netuid protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QuerySubnetRequest = File_hetu_event_v1_query_proto.Messages().ByName("QuerySubnetRequest")
	fd_QuerySubnetRequest_netuid = md_QuerySubnetRequest.Fields().ByName("netuid")
}

var _ protoreflect.Message = (*fastReflection_QuerySubnetRequest)(nil)

type fastReflection_QuerySubnetRequest QuerySubnetRequest

func (x *QuerySubnetRequest) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QuerySubnetRequest)(x)
}

func (x *QuerySubnetRequest) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QuerySubnetRequest_messageType fastReflection_QuerySubnetRequest_messageType
var _ protoreflect.MessageType = fastReflection_QuerySubnetRequest_messageType{}

type fastReflection_QuerySubnetRequest_messageType struct{}

func (x fastReflection_QuerySubnetRequest_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QuerySubnetRequest)(nil)
}
func (x fastReflection_QuerySubnetRequest_messageType) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetRequest)
}
func (x fastReflection_QuerySubnetRequest_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetRequest
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QuerySubnetRequest) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetRequest
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QuerySubnetRequest) Type() protoreflect.MessageType {
	return _fastReflection_QuerySubnetRequest_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QuerySubnetRequest) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetRequest)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QuerySubnetRequest) Interface() protoreflect.ProtoMessage {
	return (*QuerySubnetRequest)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QuerySubnetRequest) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Netuid != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Netuid)
		if !f(fd_QuerySubnetRequest_netuid, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QuerySubnetRequest) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetRequest.netuid":
		return x.Netuid != uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetRequest does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetRequest) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetRequest.netuid":
		x.Netuid = uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetRequest does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QuerySubnetRequest) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.QuerySubnetRequest.netuid":
		value := x.Netuid
		return protoreflect.ValueOfUint32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetRequest does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetRequest) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetRequest.netuid":
		x.Netuid = uint32(value.Uint())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetRequest does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetRequest) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetRequest.netuid":
		panic(fmt.Errorf("field netuid of message hetu.event.v1.QuerySubnetRequest is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetRequest does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QuerySubnetRequest) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetRequest.netuid":
		return protoreflect.ValueOfUint32(uint32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetRequest does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QuerySubnetRequest) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QuerySubnetRequest", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QuerySubnetRequest) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetRequest) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QuerySubnetRequest) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QuerySubnetRequest) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QuerySubnetRequest)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Netuid != 0 {
			n += 1 + runtime.Sov(uint64(x.Netuid))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetRequest)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Netuid != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Netuid))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetRequest)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Netuid", wireType)
				}
				x.Netuid = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Netuid |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QuerySubnetResponse        protoreflect.MessageDescriptor
	fd_QuerySubnetResponse_subnet protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QuerySubnetResponse = File_hetu_event_v1_query_proto.Messages().ByName("QuerySubnetResponse")
	fd_QuerySubnetResponse_subnet = md_QuerySubnetResponse.Fields().ByName("subnet")
}

var _ protoreflect.Message = (*fastReflection_QuerySubnetResponse)(nil)

type fastReflection_QuerySubnetResponse QuerySubnetResponse

func (x *QuerySubnetResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QuerySubnetResponse)(x)
}

func (x *QuerySubnetResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QuerySubnetResponse_messageType fastReflection_QuerySubnetResponse_messageType
var _ protoreflect.MessageType = fastReflection_QuerySubnetResponse_messageType{}

type fastReflection_QuerySubnetResponse_messageType struct{}

func (x fastReflection_QuerySubnetResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QuerySubnetResponse)(nil)
}
func (x fastReflection_QuerySubnetResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetResponse)
}
func (x fastReflection_QuerySubnetResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QuerySubnetResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QuerySubnetResponse) Type() protoreflect.MessageType {
	return _fastReflection_QuerySubnetResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QuerySubnetResponse) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QuerySubnetResponse) Interface() protoreflect.ProtoMessage {
	return (*QuerySubnetResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QuerySubnetResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Subnet != nil {
		value := protoreflect.ValueOfMessage(x.Subnet.ProtoReflect())
		if !f(fd_QuerySubnetResponse_subnet, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QuerySubnetResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetResponse.subnet":
		return x.Subnet != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetResponse.subnet":
		x.Subnet = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QuerySubnetResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.QuerySubnetResponse.subnet":
		value := x.Subnet
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetResponse.subnet":
		x.Subnet = value.Message().Interface().(*SubnetInfo)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetResponse.subnet":
		if x.Subnet == nil {
			x.Subnet = new(SubnetInfo)
		}
		return protoreflect.ValueOfMessage(x.Subnet.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QuerySubnetResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetResponse.subnet":
		m := new(SubnetInfo)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QuerySubnetResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QuerySubnetResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QuerySubnetResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QuerySubnetResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QuerySubnetResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QuerySubnetResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Subnet != nil {
			l = options.Size(x.Subnet)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Subnet != nil {
			encoded, err := options.Marshal(x.Subnet)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Subnet == nil {
					x.Subnet = &SubnetInfo{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Subnet); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QuerySubnetNeuronsRequest        protoreflect.MessageDescriptor
	fd_QuerySubnetNeuronsRequest_netuid protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QuerySubnetNeuronsRequest = File_hetu_event_v1_query_proto.Messages().ByName("QuerySubnetNeuronsRequest")
	fd_QuerySubnetNeuronsRequest_netuid = md_QuerySubnetNeuronsRequest.Fields().ByName("netuid")
}

var _ protoreflect.Message = (*fastReflection_QuerySubnetNeuronsRequest)(nil)

type fastReflection_QuerySubnetNeuronsRequest QuerySubnetNeuronsRequest

func (x *QuerySubnetNeuronsRequest) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QuerySubnetNeuronsRequest)(x)
}

func (x *QuerySubnetNeuronsRequest) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QuerySubnetNeuronsRequest_messageType fastReflection_QuerySubnetNeuronsRequest_messageType
var _ protoreflect.MessageType = fastReflection_QuerySubnetNeuronsRequest_messageType{}

type fastReflection_QuerySubnetNeuronsRequest_messageType struct{}

func (x fastReflection_QuerySubnetNeuronsRequest_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QuerySubnetNeuronsRequest)(nil)
}
func (x fastReflection_QuerySubnetNeuronsRequest_messageType) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetNeuronsRequest)
}
func (x fastReflection_QuerySubnetNeuronsRequest_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetNeuronsRequest
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QuerySubnetNeuronsRequest) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetNeuronsRequest
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QuerySubnetNeuronsRequest) Type() protoreflect.MessageType {
	return _fastReflection_QuerySubnetNeuronsRequest_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QuerySubnetNeuronsRequest) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetNeuronsRequest)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QuerySubnetNeuronsRequest) Interface() protoreflect.ProtoMessage {
	return (*QuerySubnetNeuronsRequest)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QuerySubnetNeuronsRequest) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Netuid != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Netuid)
		if !f(fd_QuerySubnetNeuronsRequest_netuid, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QuerySubnetNeuronsRequest) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsRequest.netuid":
		return x.Netuid != uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsRequest does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetNeuronsRequest) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsRequest.netuid":
		x.Netuid = uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsRequest does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QuerySubnetNeuronsRequest) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsRequest.netuid":
		value := x.Netuid
		return protoreflect.ValueOfUint32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsRequest does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetNeuronsRequest) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsRequest.netuid":
		x.Netuid = uint32(value.Uint())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsRequest does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetNeuronsRequest) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsRequest.netuid":
		panic(fmt.Errorf("field netuid of message hetu.event.v1.QuerySubnetNeuronsRequest is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsRequest does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QuerySubnetNeuronsRequest) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsRequest.netuid":
		return protoreflect.ValueOfUint32(uint32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsRequest does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QuerySubnetNeuronsRequest) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QuerySubnetNeuronsRequest", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QuerySubnetNeuronsRequest) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetNeuronsRequest) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QuerySubnetNeuronsRequest) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QuerySubnetNeuronsRequest) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QuerySubnetNeuronsRequest)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Netuid != 0 {
			n += 1 + runtime.Sov(uint64(x.Netuid))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetNeuronsRequest)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Netuid != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Netuid))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetNeuronsRequest)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetNeuronsRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetNeuronsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Netuid", wireType)
				}
				x.Netuid = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Netuid |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_QuerySubnetNeuronsResponse_1_list)(nil)

type _QuerySubnetNeuronsResponse_1_list struct {
	list *[]*NeuronInfo
}

func (x *_QuerySubnetNeuronsResponse_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_QuerySubnetNeuronsResponse_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_QuerySubnetNeuronsResponse_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*NeuronInfo)
	(*x.list)[i] = concreteValue
}

func (x *_QuerySubnetNeuronsResponse_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*NeuronInfo)
	*x.list = append(*x.list, concreteValue)
}

func (x *_QuerySubnetNeuronsResponse_1_list) AppendMutable() protoreflect.Value {
	v := new(NeuronInfo)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_QuerySubnetNeuronsResponse_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_QuerySubnetNeuronsResponse_1_list) NewElement() protoreflect.Value {
	v := new(NeuronInfo)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_QuerySubnetNeuronsResponse_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_QuerySubnetNeuronsResponse         protoreflect.MessageDescriptor
	fd_QuerySubnetNeuronsResponse_neurons protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QuerySubnetNeuronsResponse = File_hetu_event_v1_query_proto.Messages().ByName("QuerySubnetNeuronsResponse")
	fd_QuerySubnetNeuronsResponse_neurons = md_QuerySubnetNeuronsResponse.Fields().ByName("neurons")
}

var _ protoreflect.Message = (*fastReflection_QuerySubnetNeuronsResponse)(nil)

type fastReflection_QuerySubnetNeuronsResponse QuerySubnetNeuronsResponse

func (x *QuerySubnetNeuronsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QuerySubnetNeuronsResponse)(x)
}

func (x *QuerySubnetNeuronsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QuerySubnetNeuronsResponse_messageType fastReflection_QuerySubnetNeuronsResponse_messageType
var _ protoreflect.MessageType = fastReflection_QuerySubnetNeuronsResponse_messageType{}

type fastReflection_QuerySubnetNeuronsResponse_messageType struct{}

func (x fastReflection_QuerySubnetNeuronsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QuerySubnetNeuronsResponse)(nil)
}
func (x fastReflection_QuerySubnetNeuronsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetNeuronsResponse)
}
func (x fastReflection_QuerySubnetNeuronsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetNeuronsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QuerySubnetNeuronsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetNeuronsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QuerySubnetNeuronsResponse) Type() protoreflect.MessageType {
	return _fastReflection_QuerySubnetNeuronsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QuerySubnetNeuronsResponse) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetNeuronsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QuerySubnetNeuronsResponse) Interface() protoreflect.ProtoMessage {
	return (*QuerySubnetNeuronsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QuerySubnetNeuronsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Neurons) != 0 {
		value := protoreflect.ValueOfList(&_QuerySubnetNeuronsResponse_1_list{list: &x.Neurons})
		if !f(fd_QuerySubnetNeuronsResponse_neurons, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QuerySubnetNeuronsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsResponse.neurons":
		return len(x.Neurons) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetNeuronsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsResponse.neurons":
		x.Neurons = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QuerySubnetNeuronsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsResponse.neurons":
		if len(x.Neurons) == 0 {
			return protoreflect.ValueOfList(&_QuerySubnetNeuronsResponse_1_list{})
		}
		listValue := &_QuerySubnetNeuronsResponse_1_list{list: &x.Neurons}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetNeuronsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsResponse.neurons":
		lv := value.List()
		clv := lv.(*_QuerySubnetNeuronsResponse_1_list)
		x.Neurons = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetNeuronsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsResponse.neurons":
		if x.Neurons == nil {
			x.Neurons = []*NeuronInfo{}
		}
		value := &_QuerySubnetNeuronsResponse_1_list{list: &x.Neurons}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QuerySubnetNeuronsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetNeuronsResponse.neurons":
		list := []*NeuronInfo{}
		return protoreflect.ValueOfList(&_QuerySubnetNeuronsResponse_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetNeuronsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetNeuronsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QuerySubnetNeuronsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QuerySubnetNeuronsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QuerySubnetNeuronsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetNeuronsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QuerySubnetNeuronsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QuerySubnetNeuronsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QuerySubnetNeuronsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Neurons) > 0 {
			for _, e := range x.Neurons {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetNeuronsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Neurons) > 0 {
			for iNdEx := len(x.Neurons) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Neurons[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetNeuronsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetNeuronsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetNeuronsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Neurons", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Neurons = append(x.Neurons, &NeuronInfo{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Neurons[len(x.Neurons)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QuerySubnetPoolRequest        protoreflect.MessageDescriptor
	fd_QuerySubnetPoolRequest_netuid protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QuerySubnetPoolRequest = File_hetu_event_v1_query_proto.Messages().ByName("QuerySubnetPoolRequest")
	fd_QuerySubnetPoolRequest_netuid = md_QuerySubnetPoolRequest.Fields().ByName("netuid")
}

var _ protoreflect.Message = (*fastReflection_QuerySubnetPoolRequest)(nil)

type fastReflection_QuerySubnetPoolRequest QuerySubnetPoolRequest

func (x *QuerySubnetPoolRequest) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QuerySubnetPoolRequest)(x)
}

func (x *QuerySubnetPoolRequest) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QuerySubnetPoolRequest_messageType fastReflection_QuerySubnetPoolRequest_messageType
var _ protoreflect.MessageType = fastReflection_QuerySubnetPoolRequest_messageType{}

type fastReflection_QuerySubnetPoolRequest_messageType struct{}

func (x fastReflection_QuerySubnetPoolRequest_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QuerySubnetPoolRequest)(nil)
}
func (x fastReflection_QuerySubnetPoolRequest_messageType) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetPoolRequest)
}
func (x fastReflection_QuerySubnetPoolRequest_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetPoolRequest
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QuerySubnetPoolRequest) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetPoolRequest
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QuerySubnetPoolRequest) Type() protoreflect.MessageType {
	return _fastReflection_QuerySubnetPoolRequest_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QuerySubnetPoolRequest) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetPoolRequest)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QuerySubnetPoolRequest) Interface() protoreflect.ProtoMessage {
	return (*QuerySubnetPoolRequest)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QuerySubnetPoolRequest) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Netuid != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Netuid)
		if !f(fd_QuerySubnetPoolRequest_netuid, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QuerySubnetPoolRequest) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolRequest.netuid":
		return x.Netuid != uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolRequest does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetPoolRequest) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolRequest.netuid":
		x.Netuid = uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolRequest does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QuerySubnetPoolRequest) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.QuerySubnetPoolRequest.netuid":
		value := x.Netuid
		return protoreflect.ValueOfUint32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolRequest does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetPoolRequest) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolRequest.netuid":
		x.Netuid = uint32(value.Uint())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolRequest does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetPoolRequest) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolRequest.netuid":
		panic(fmt.Errorf("field netuid of message hetu.event.v1.QuerySubnetPoolRequest is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolRequest does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QuerySubnetPoolRequest) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolRequest.netuid":
		return protoreflect.ValueOfUint32(uint32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolRequest does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QuerySubnetPoolRequest) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QuerySubnetPoolRequest", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QuerySubnetPoolRequest) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetPoolRequest) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QuerySubnetPoolRequest) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QuerySubnetPoolRequest) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QuerySubnetPoolRequest)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Netuid != 0 {
			n += 1 + runtime.Sov(uint64(x.Netuid))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetPoolRequest)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Netuid != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Netuid))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetPoolRequest)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetPoolRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetPoolRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Netuid", wireType)
				}
				x.Netuid = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Netuid |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QuerySubnetPoolResponse                  protoreflect.MessageDescriptor
	fd_QuerySubnetPoolResponse_netuid           protoreflect.FieldDescriptor
	fd_QuerySubnetPoolResponse_amm_pool         protoreflect.FieldDescriptor
	fd_QuerySubnetPoolResponse_locked_amount    protoreflect.FieldDescriptor
	fd_QuerySubnetPoolResponse_burned_amount    protoreflect.FieldDescriptor
	fd_QuerySubnetPoolResponse_subnet_tao_in    protoreflect.FieldDescriptor
	fd_QuerySubnetPoolResponse_subnet_alpha_in  protoreflect.FieldDescriptor
	fd_QuerySubnetPoolResponse_subnet_alpha_out protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QuerySubnetPoolResponse = File_hetu_event_v1_query_proto.Messages().ByName("QuerySubnetPoolResponse")
	fd_QuerySubnetPoolResponse_netuid = md_QuerySubnetPoolResponse.Fields().ByName("netuid")
	fd_QuerySubnetPoolResponse_amm_pool = md_QuerySubnetPoolResponse.Fields().ByName("amm_pool")
	fd_QuerySubnetPoolResponse_locked_amount = md_QuerySubnetPoolResponse.Fields().ByName("locked_amount")
	fd_QuerySubnetPoolResponse_burned_amount = md_QuerySubnetPoolResponse.Fields().ByName("burned_amount")
	fd_QuerySubnetPoolResponse_subnet_tao_in = md_QuerySubnetPoolResponse.Fields().ByName("subnet_tao_in")
	fd_QuerySubnetPoolResponse_subnet_alpha_in = md_QuerySubnetPoolResponse.Fields().ByName("subnet_alpha_in")
	fd_QuerySubnetPoolResponse_subnet_alpha_out = md_QuerySubnetPoolResponse.Fields().ByName("subnet_alpha_out")
}

var _ protoreflect.Message = (*fastReflection_QuerySubnetPoolResponse)(nil)

type fastReflection_QuerySubnetPoolResponse QuerySubnetPoolResponse

func (x *QuerySubnetPoolResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QuerySubnetPoolResponse)(x)
}

func (x *QuerySubnetPoolResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QuerySubnetPoolResponse_messageType fastReflection_QuerySubnetPoolResponse_messageType
var _ protoreflect.MessageType = fastReflection_QuerySubnetPoolResponse_messageType{}

type fastReflection_QuerySubnetPoolResponse_messageType struct{}

func (x fastReflection_QuerySubnetPoolResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QuerySubnetPoolResponse)(nil)
}
func (x fastReflection_QuerySubnetPoolResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetPoolResponse)
}
func (x fastReflection_QuerySubnetPoolResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetPoolResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QuerySubnetPoolResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_QuerySubnetPoolResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QuerySubnetPoolResponse) Type() protoreflect.MessageType {
	return _fastReflection_QuerySubnetPoolResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QuerySubnetPoolResponse) New() protoreflect.Message {
	return new(fastReflection_QuerySubnetPoolResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QuerySubnetPoolResponse) Interface() protoreflect.ProtoMessage {
	return (*QuerySubnetPoolResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QuerySubnetPoolResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Netuid != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Netuid)
		if !f(fd_QuerySubnetPoolResponse_netuid, value) {
			return
		}
	}
	if x.AmmPool != "" {
		value := protoreflect.ValueOfString(x.AmmPool)
		if !f(fd_QuerySubnetPoolResponse_amm_pool, value) {
			return
		}
	}
	if x.LockedAmount != "" {
		value := protoreflect.ValueOfString(x.LockedAmount)
		if !f(fd_QuerySubnetPoolResponse_locked_amount, value) {
			return
		}
	}
	if x.BurnedAmount != "" {
		value := protoreflect.ValueOfString(x.BurnedAmount)
		if !f(fd_QuerySubnetPoolResponse_burned_amount, value) {
			return
		}
	}
	if x.SubnetTaoIn != "" {
		value := protoreflect.ValueOfString(x.SubnetTaoIn)
		if !f(fd_QuerySubnetPoolResponse_subnet_tao_in, value) {
			return
		}
	}
	if x.SubnetAlphaIn != "" {
		value := protoreflect.ValueOfString(x.SubnetAlphaIn)
		if !f(fd_QuerySubnetPoolResponse_subnet_alpha_in, value) {
			return
		}
	}
	if x.SubnetAlphaOut != "" {
		value := protoreflect.ValueOfString(x.SubnetAlphaOut)
		if !f(fd_QuerySubnetPoolResponse_subnet_alpha_out, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QuerySubnetPoolResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolResponse.netuid":
		return x.Netuid != uint32(0)
	case "hetu.event.v1.QuerySubnetPoolResponse.amm_pool":
		return x.AmmPool != ""
	case "hetu.event.v1.QuerySubnetPoolResponse.locked_amount":
		return x.LockedAmount != ""
	case "hetu.event.v1.QuerySubnetPoolResponse.burned_amount":
		return x.BurnedAmount != ""
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_tao_in":
		return x.SubnetTaoIn != ""
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_in":
		return x.SubnetAlphaIn != ""
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_out":
		return x.SubnetAlphaOut != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetPoolResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolResponse.netuid":
		x.Netuid = uint32(0)
	case "hetu.event.v1.QuerySubnetPoolResponse.amm_pool":
		x.AmmPool = ""
	case "hetu.event.v1.QuerySubnetPoolResponse.locked_amount":
		x.LockedAmount = ""
	case "hetu.event.v1.QuerySubnetPoolResponse.burned_amount":
		x.BurnedAmount = ""
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_tao_in":
		x.SubnetTaoIn = ""
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_in":
		x.SubnetAlphaIn = ""
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_out":
		x.SubnetAlphaOut = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QuerySubnetPoolResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.QuerySubnetPoolResponse.netuid":
		value := x.Netuid
		return protoreflect.ValueOfUint32(value)
	case "hetu.event.v1.QuerySubnetPoolResponse.amm_pool":
		value := x.AmmPool
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.QuerySubnetPoolResponse.locked_amount":
		value := x.LockedAmount
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.QuerySubnetPoolResponse.burned_amount":
		value := x.BurnedAmount
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_tao_in":
		value := x.SubnetTaoIn
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_in":
		value := x.SubnetAlphaIn
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_out":
		value := x.SubnetAlphaOut
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetPoolResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolResponse.netuid":
		x.Netuid = uint32(value.Uint())
	case "hetu.event.v1.QuerySubnetPoolResponse.amm_pool":
		x.AmmPool = value.Interface().(string)
	case "hetu.event.v1.QuerySubnetPoolResponse.locked_amount":
		x.LockedAmount = value.Interface().(string)
	case "hetu.event.v1.QuerySubnetPoolResponse.burned_amount":
		x.BurnedAmount = value.Interface().(string)
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_tao_in":
		x.SubnetTaoIn = value.Interface().(string)
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_in":
		x.SubnetAlphaIn = value.Interface().(string)
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_out":
		x.SubnetAlphaOut = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetPoolResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolResponse.netuid":
		panic(fmt.Errorf("field netuid of message hetu.event.v1.QuerySubnetPoolResponse is not mutable"))
	case "hetu.event.v1.QuerySubnetPoolResponse.amm_pool":
		panic(fmt.Errorf("field amm_pool of message hetu.event.v1.QuerySubnetPoolResponse is not mutable"))
	case "hetu.event.v1.QuerySubnetPoolResponse.locked_amount":
		panic(fmt.Errorf("field locked_amount of message hetu.event.v1.QuerySubnetPoolResponse is not mutable"))
	case "hetu.event.v1.QuerySubnetPoolResponse.burned_amount":
		panic(fmt.Errorf("field burned_amount of message hetu.event.v1.QuerySubnetPoolResponse is not mutable"))
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_tao_in":
		panic(fmt.Errorf("field subnet_tao_in of message hetu.event.v1.QuerySubnetPoolResponse is not mutable"))
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_in":
		panic(fmt.Errorf("field subnet_alpha_in of message hetu.event.v1.QuerySubnetPoolResponse is not mutable"))
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_out":
		panic(fmt.Errorf("field subnet_alpha_out of message hetu.event.v1.QuerySubnetPoolResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QuerySubnetPoolResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QuerySubnetPoolResponse.netuid":
		return protoreflect.ValueOfUint32(uint32(0))
	case "hetu.event.v1.QuerySubnetPoolResponse.amm_pool":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.QuerySubnetPoolResponse.locked_amount":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.QuerySubnetPoolResponse.burned_amount":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_tao_in":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_in":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.QuerySubnetPoolResponse.subnet_alpha_out":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QuerySubnetPoolResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QuerySubnetPoolResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QuerySubnetPoolResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QuerySubnetPoolResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QuerySubnetPoolResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QuerySubnetPoolResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QuerySubnetPoolResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QuerySubnetPoolResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QuerySubnetPoolResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Netuid != 0 {
			n += 1 + runtime.Sov(uint64(x.Netuid))
		}
		l = len(x.AmmPool)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LockedAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BurnedAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SubnetTaoIn)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SubnetAlphaIn)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SubnetAlphaOut)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetPoolResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SubnetAlphaOut) > 0 {
			i -= len(x.SubnetAlphaOut)
			copy(dAtA[i:], x.SubnetAlphaOut)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SubnetAlphaOut)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.SubnetAlphaIn) > 0 {
			i -= len(x.SubnetAlphaIn)
			copy(dAtA[i:], x.SubnetAlphaIn)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SubnetAlphaIn)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.SubnetTaoIn) > 0 {
			i -= len(x.SubnetTaoIn)
			copy(dAtA[i:], x.SubnetTaoIn)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SubnetTaoIn)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.BurnedAmount) > 0 {
			i -= len(x.BurnedAmount)
			copy(dAtA[i:], x.BurnedAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BurnedAmount)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.LockedAmount) > 0 {
			i -= len(x.LockedAmount)
			copy(dAtA[i:], x.LockedAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LockedAmount)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.AmmPool) > 0 {
			i -= len(x.AmmPool)
			copy(dAtA[i:], x.AmmPool)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AmmPool)))
			i--
			dAtA[i] = 0x12
		}
		if x.Netuid != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Netuid))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QuerySubnetPoolResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetPoolResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QuerySubnetPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Netuid", wireType)
				}
				x.Netuid = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Netuid |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AmmPool", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AmmPool = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LockedAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LockedAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BurnedAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BurnedAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SubnetTaoIn", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SubnetTaoIn = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SubnetAlphaIn", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SubnetAlphaIn = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SubnetAlphaOut", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SubnetAlphaOut = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QueryValidatorWeightsRequest           protoreflect.MessageDescriptor
	fd_QueryValidatorWeightsRequest_netuid    protoreflect.FieldDescriptor
	fd_QueryValidatorWeightsRequest_validator protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QueryValidatorWeightsRequest = File_hetu_event_v1_query_proto.Messages().ByName("QueryValidatorWeightsRequest")
	fd_QueryValidatorWeightsRequest_netuid = md_QueryValidatorWeightsRequest.Fields().ByName("netuid")
	fd_QueryValidatorWeightsRequest_validator = md_QueryValidatorWeightsRequest.Fields().ByName("validator")
}

var _ protoreflect.Message = (*fastReflection_QueryValidatorWeightsRequest)(nil)

type fastReflection_QueryValidatorWeightsRequest QueryValidatorWeightsRequest

func (x *QueryValidatorWeightsRequest) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QueryValidatorWeightsRequest)(x)
}

func (x *QueryValidatorWeightsRequest) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QueryValidatorWeightsRequest_messageType fastReflection_QueryValidatorWeightsRequest_messageType
var _ protoreflect.MessageType = fastReflection_QueryValidatorWeightsRequest_messageType{}

type fastReflection_QueryValidatorWeightsRequest_messageType struct{}

func (x fastReflection_QueryValidatorWeightsRequest_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QueryValidatorWeightsRequest)(nil)
}
func (x fastReflection_QueryValidatorWeightsRequest_messageType) New() protoreflect.Message {
	return new(fastReflection_QueryValidatorWeightsRequest)
}
func (x fastReflection_QueryValidatorWeightsRequest_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryValidatorWeightsRequest
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QueryValidatorWeightsRequest) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryValidatorWeightsRequest
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QueryValidatorWeightsRequest) Type() protoreflect.MessageType {
	return _fastReflection_QueryValidatorWeightsRequest_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QueryValidatorWeightsRequest) New() protoreflect.Message {
	return new(fastReflection_QueryValidatorWeightsRequest)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QueryValidatorWeightsRequest) Interface() protoreflect.ProtoMessage {
	return (*QueryValidatorWeightsRequest)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QueryValidatorWeightsRequest) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Netuid != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Netuid)
		if !f(fd_QueryValidatorWeightsRequest_netuid, value) {
			return
		}
	}
	if x.Validator != "" {
		value := protoreflect.ValueOfString(x.Validator)
		if !f(fd_QueryValidatorWeightsRequest_validator, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QueryValidatorWeightsRequest) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsRequest.netuid":
		return x.Netuid != uint32(0)
	case "hetu.event.v1.QueryValidatorWeightsRequest.validator":
		return x.Validator != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsRequest does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryValidatorWeightsRequest) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsRequest.netuid":
		x.Netuid = uint32(0)
	case "hetu.event.v1.QueryValidatorWeightsRequest.validator":
		x.Validator = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsRequest does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QueryValidatorWeightsRequest) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsRequest.netuid":
		value := x.Netuid
		return protoreflect.ValueOfUint32(value)
	case "hetu.event.v1.QueryValidatorWeightsRequest.validator":
		value := x.Validator
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsRequest does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryValidatorWeightsRequest) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsRequest.netuid":
		x.Netuid = uint32(value.Uint())
	case "hetu.event.v1.QueryValidatorWeightsRequest.validator":
		x.Validator = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsRequest does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryValidatorWeightsRequest) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsRequest.netuid":
		panic(fmt.Errorf("field netuid of message hetu.event.v1.QueryValidatorWeightsRequest is not mutable"))
	case "hetu.event.v1.QueryValidatorWeightsRequest.validator":
		panic(fmt.Errorf("field validator of message hetu.event.v1.QueryValidatorWeightsRequest is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsRequest does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QueryValidatorWeightsRequest) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsRequest.netuid":
		return protoreflect.ValueOfUint32(uint32(0))
	case "hetu.event.v1.QueryValidatorWeightsRequest.validator":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsRequest"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsRequest does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QueryValidatorWeightsRequest) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QueryValidatorWeightsRequest", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QueryValidatorWeightsRequest) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryValidatorWeightsRequest) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QueryValidatorWeightsRequest) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QueryValidatorWeightsRequest) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QueryValidatorWeightsRequest)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Netuid != 0 {
			n += 1 + runtime.Sov(uint64(x.Netuid))
		}
		l = len(x.Validator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QueryValidatorWeightsRequest)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Validator) > 0 {
			i -= len(x.Validator)
			copy(dAtA[i:], x.Validator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Validator)))
			i--
			dAtA[i] = 0x12
		}
		if x.Netuid != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Netuid))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QueryValidatorWeightsRequest)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryValidatorWeightsRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryValidatorWeightsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Netuid", wireType)
				}
				x.Netuid = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Netuid |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Validator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_QueryValidatorWeightsResponse_3_list)(nil)

type _QueryValidatorWeightsResponse_3_list struct {
	list *[]string
}

func (x *_QueryValidatorWeightsResponse_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_QueryValidatorWeightsResponse_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_QueryValidatorWeightsResponse_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_QueryValidatorWeightsResponse_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_QueryValidatorWeightsResponse_3_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message QueryValidatorWeightsResponse at list field Weights as it is not of Message kind"))
}

func (x *_QueryValidatorWeightsResponse_3_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_QueryValidatorWeightsResponse_3_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_QueryValidatorWeightsResponse_3_list) IsValid() bool {
	return x.list != nil
}

var (
	md_QueryValidatorWeightsResponse           protoreflect.MessageDescriptor
	fd_QueryValidatorWeightsResponse_netuid    protoreflect.FieldDescriptor
	fd_QueryValidatorWeightsResponse_validator protoreflect.FieldDescriptor
	fd_QueryValidatorWeightsResponse_weights   protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_QueryValidatorWeightsResponse = File_hetu_event_v1_query_proto.Messages().ByName("QueryValidatorWeightsResponse")
	fd_QueryValidatorWeightsResponse_netuid = md_QueryValidatorWeightsResponse.Fields().ByName("netuid")
	fd_QueryValidatorWeightsResponse_validator = md_QueryValidatorWeightsResponse.Fields().ByName("validator")
	fd_QueryValidatorWeightsResponse_weights = md_QueryValidatorWeightsResponse.Fields().ByName("weights")
}

var _ protoreflect.Message = (*fastReflection_QueryValidatorWeightsResponse)(nil)

type fastReflection_QueryValidatorWeightsResponse QueryValidatorWeightsResponse

func (x *QueryValidatorWeightsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QueryValidatorWeightsResponse)(x)
}

func (x *QueryValidatorWeightsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QueryValidatorWeightsResponse_messageType fastReflection_QueryValidatorWeightsResponse_messageType
var _ protoreflect.MessageType = fastReflection_QueryValidatorWeightsResponse_messageType{}

type fastReflection_QueryValidatorWeightsResponse_messageType struct{}

func (x fastReflection_QueryValidatorWeightsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QueryValidatorWeightsResponse)(nil)
}
func (x fastReflection_QueryValidatorWeightsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_QueryValidatorWeightsResponse)
}
func (x fastReflection_QueryValidatorWeightsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryValidatorWeightsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QueryValidatorWeightsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryValidatorWeightsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QueryValidatorWeightsResponse) Type() protoreflect.MessageType {
	return _fastReflection_QueryValidatorWeightsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QueryValidatorWeightsResponse) New() protoreflect.Message {
	return new(fastReflection_QueryValidatorWeightsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QueryValidatorWeightsResponse) Interface() protoreflect.ProtoMessage {
	return (*QueryValidatorWeightsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QueryValidatorWeightsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Netuid != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Netuid)
		if !f(fd_QueryValidatorWeightsResponse_netuid, value) {
			return
		}
	}
	if x.Validator != "" {
		value := protoreflect.ValueOfString(x.Validator)
		if !f(fd_QueryValidatorWeightsResponse_validator, value) {
			return
		}
	}
	if len(x.Weights) != 0 {
		value := protoreflect.ValueOfList(&_QueryValidatorWeightsResponse_3_list{list: &x.Weights})
		if !f(fd_QueryValidatorWeightsResponse_weights, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QueryValidatorWeightsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsResponse.netuid":
		return x.Netuid != uint32(0)
	case "hetu.event.v1.QueryValidatorWeightsResponse.validator":
		return x.Validator != ""
	case "hetu.event.v1.QueryValidatorWeightsResponse.weights":
		return len(x.Weights) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryValidatorWeightsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsResponse.netuid":
		x.Netuid = uint32(0)
	case "hetu.event.v1.QueryValidatorWeightsResponse.validator":
		x.Validator = ""
	case "hetu.event.v1.QueryValidatorWeightsResponse.weights":
		x.Weights = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QueryValidatorWeightsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsResponse.netuid":
		value := x.Netuid
		return protoreflect.ValueOfUint32(value)
	case "hetu.event.v1.QueryValidatorWeightsResponse.validator":
		value := x.Validator
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.QueryValidatorWeightsResponse.weights":
		if len(x.Weights) == 0 {
			return protoreflect.ValueOfList(&_QueryValidatorWeightsResponse_3_list{})
		}
		listValue := &_QueryValidatorWeightsResponse_3_list{list: &x.Weights}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryValidatorWeightsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsResponse.netuid":
		x.Netuid = uint32(value.Uint())
	case "hetu.event.v1.QueryValidatorWeightsResponse.validator":
		x.Validator = value.Interface().(string)
	case "hetu.event.v1.QueryValidatorWeightsResponse.weights":
		lv := value.List()
		clv := lv.(*_QueryValidatorWeightsResponse_3_list)
		x.Weights = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryValidatorWeightsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsResponse.weights":
		if x.Weights == nil {
			x.Weights = []string{}
		}
		value := &_QueryValidatorWeightsResponse_3_list{list: &x.Weights}
		return protoreflect.ValueOfList(value)
	case "hetu.event.v1.QueryValidatorWeightsResponse.netuid":
		panic(fmt.Errorf("field netuid of message hetu.event.v1.QueryValidatorWeightsResponse is not mutable"))
	case "hetu.event.v1.QueryValidatorWeightsResponse.validator":
		panic(fmt.Errorf("field validator of message hetu.event.v1.QueryValidatorWeightsResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QueryValidatorWeightsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.QueryValidatorWeightsResponse.netuid":
		return protoreflect.ValueOfUint32(uint32(0))
	case "hetu.event.v1.QueryValidatorWeightsResponse.validator":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.QueryValidatorWeightsResponse.weights":
		list := []string{}
		return protoreflect.ValueOfList(&_QueryValidatorWeightsResponse_3_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.QueryValidatorWeightsResponse"))
		}
		panic(fmt.Errorf("message hetu.event.v1.QueryValidatorWeightsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QueryValidatorWeightsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.QueryValidatorWeightsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QueryValidatorWeightsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryValidatorWeightsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QueryValidatorWeightsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QueryValidatorWeightsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QueryValidatorWeightsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Netuid != 0 {
			n += 1 + runtime.Sov(uint64(x.Netuid))
		}
		l = len(x.Validator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Weights) > 0 {
			for _, s := range x.Weights {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QueryValidatorWeightsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Weights) > 0 {
			for iNdEx := len(x.Weights) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Weights[iNdEx])
				copy(dAtA[i:], x.Weights[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Weights[iNdEx])))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.Validator) > 0 {
			i -= len(x.Validator)
			copy(dAtA[i:], x.Validator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Validator)))
			i--
			dAtA[i] = 0x12
		}
		if x.Netuid != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Netuid))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QueryValidatorWeightsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryValidatorWeightsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryValidatorWeightsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Netuid", wireType)
				}
				x.Netuid = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Netuid |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Validator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Weights = append(x.Weights, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_SubnetInfo                  protoreflect.MessageDescriptor
	fd_SubnetInfo_netuid           protoreflect.FieldDescriptor
	fd_SubnetInfo_owner            protoreflect.FieldDescriptor
	fd_SubnetInfo_alpha_token      protoreflect.FieldDescriptor
	fd_SubnetInfo_amm_pool         protoreflect.FieldDescriptor
	fd_SubnetInfo_locked_amount    protoreflect.FieldDescriptor
	fd_SubnetInfo_pool_initial_tao protoreflect.FieldDescriptor
	fd_SubnetInfo_burned_amount    protoreflect.FieldDescriptor
	fd_SubnetInfo_created_at       protoreflect.FieldDescriptor
	fd_SubnetInfo_is_active        protoreflect.FieldDescriptor
	fd_SubnetInfo_name             protoreflect.FieldDescriptor
	fd_SubnetInfo_description      protoreflect.FieldDescriptor
	fd_SubnetInfo_activated_at     protoreflect.FieldDescriptor
	fd_SubnetInfo_activated_block  protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_SubnetInfo = File_hetu_event_v1_query_proto.Messages().ByName("SubnetInfo")
	fd_SubnetInfo_netuid = md_SubnetInfo.Fields().ByName("netuid")
	fd_SubnetInfo_owner = md_SubnetInfo.Fields().ByName("owner")
	fd_SubnetInfo_alpha_token = md_SubnetInfo.Fields().ByName("alpha_token")
	fd_SubnetInfo_amm_pool = md_SubnetInfo.Fields().ByName("amm_pool")
	fd_SubnetInfo_locked_amount = md_SubnetInfo.Fields().ByName("locked_amount")
	fd_SubnetInfo_pool_initial_tao = md_SubnetInfo.Fields().ByName("pool_initial_tao")
	fd_SubnetInfo_burned_amount = md_SubnetInfo.Fields().ByName("burned_amount")
	fd_SubnetInfo_created_at = md_SubnetInfo.Fields().ByName("created_at")
	fd_SubnetInfo_is_active = md_SubnetInfo.Fields().ByName("is_active")
	fd_SubnetInfo_name = md_SubnetInfo.Fields().ByName("name")
	fd_SubnetInfo_description = md_SubnetInfo.Fields().ByName("description")
	fd_SubnetInfo_activated_at = md_SubnetInfo.Fields().ByName("activated_at")
	fd_SubnetInfo_activated_block = md_SubnetInfo.Fields().ByName("activated_block")
}

var _ protoreflect.Message = (*fastReflection_SubnetInfo)(nil)

type fastReflection_SubnetInfo SubnetInfo

func (x *SubnetInfo) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SubnetInfo)(x)
}

func (x *SubnetInfo) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SubnetInfo_messageType fastReflection_SubnetInfo_messageType
var _ protoreflect.MessageType = fastReflection_SubnetInfo_messageType{}

type fastReflection_SubnetInfo_messageType struct{}

func (x fastReflection_SubnetInfo_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SubnetInfo)(nil)
}
func (x fastReflection_SubnetInfo_messageType) New() protoreflect.Message {
	return new(fastReflection_SubnetInfo)
}
func (x fastReflection_SubnetInfo_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SubnetInfo
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SubnetInfo) Descriptor() protoreflect.MessageDescriptor {
	return md_SubnetInfo
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SubnetInfo) Type() protoreflect.MessageType {
	return _fastReflection_SubnetInfo_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SubnetInfo) New() protoreflect.Message {
	return new(fastReflection_SubnetInfo)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SubnetInfo) Interface() protoreflect.ProtoMessage {
	return (*SubnetInfo)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SubnetInfo) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Netuid != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Netuid)
		if !f(fd_SubnetInfo_netuid, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_SubnetInfo_owner, value) {
			return
		}
	}
	if x.AlphaToken != "" {
		value := protoreflect.ValueOfString(x.AlphaToken)
		if !f(fd_SubnetInfo_alpha_token, value) {
			return
		}
	}
	if x.AmmPool != "" {
		value := protoreflect.ValueOfString(x.AmmPool)
		if !f(fd_SubnetInfo_amm_pool, value) {
			return
		}
	}
	if x.LockedAmount != "" {
		value := protoreflect.ValueOfString(x.LockedAmount)
		if !f(fd_SubnetInfo_locked_amount, value) {
			return
		}
	}
	if x.PoolInitialTao != "" {
		value := protoreflect.ValueOfString(x.PoolInitialTao)
		if !f(fd_SubnetInfo_pool_initial_tao, value) {
			return
		}
	}
	if x.BurnedAmount != "" {
		value := protoreflect.ValueOfString(x.BurnedAmount)
		if !f(fd_SubnetInfo_burned_amount, value) {
			return
		}
	}
	if x.CreatedAt != uint64(0) {
		value := protoreflect.ValueOfUint64(x.CreatedAt)
		if !f(fd_SubnetInfo_created_at, value) {
			return
		}
	}
	if x.IsActive != false {
		value := protoreflect.ValueOfBool(x.IsActive)
		if !f(fd_SubnetInfo_is_active, value) {
			return
		}
	}
	if x.Name != "" {
		value := protoreflect.ValueOfString(x.Name)
		if !f(fd_SubnetInfo_name, value) {
			return
		}
	}
	if x.Description != "" {
		value := protoreflect.ValueOfString(x.Description)
		if !f(fd_SubnetInfo_description, value) {
			return
		}
	}
	if x.ActivatedAt != uint64(0) {
		value := protoreflect.ValueOfUint64(x.ActivatedAt)
		if !f(fd_SubnetInfo_activated_at, value) {
			return
		}
	}
	if x.ActivatedBlock != uint64(0) {
		value := protoreflect.ValueOfUint64(x.ActivatedBlock)
		if !f(fd_SubnetInfo_activated_block, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SubnetInfo) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.SubnetInfo.netuid":
		return x.Netuid != uint32(0)
	case "hetu.event.v1.SubnetInfo.owner":
		return x.Owner != ""
	case "hetu.event.v1.SubnetInfo.alpha_token":
		return x.AlphaToken != ""
	case "hetu.event.v1.SubnetInfo.amm_pool":
		return x.AmmPool != ""
	case "hetu.event.v1.SubnetInfo.locked_amount":
		return x.LockedAmount != ""
	case "hetu.event.v1.SubnetInfo.pool_initial_tao":
		return x.PoolInitialTao != ""
	case "hetu.event.v1.SubnetInfo.burned_amount":
		return x.BurnedAmount != ""
	case "hetu.event.v1.SubnetInfo.created_at":
		return x.CreatedAt != uint64(0)
	case "hetu.event.v1.SubnetInfo.is_active":
		return x.IsActive != false
	case "hetu.event.v1.SubnetInfo.name":
		return x.Name != ""
	case "hetu.event.v1.SubnetInfo.description":
		return x.Description != ""
	case "hetu.event.v1.SubnetInfo.activated_at":
		return x.ActivatedAt != uint64(0)
	case "hetu.event.v1.SubnetInfo.activated_block":
		return x.ActivatedBlock != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.SubnetInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.SubnetInfo does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SubnetInfo) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.SubnetInfo.netuid":
		x.Netuid = uint32(0)
	case "hetu.event.v1.SubnetInfo.owner":
		x.Owner = ""
	case "hetu.event.v1.SubnetInfo.alpha_token":
		x.AlphaToken = ""
	case "hetu.event.v1.SubnetInfo.amm_pool":
		x.AmmPool = ""
	case "hetu.event.v1.SubnetInfo.locked_amount":
		x.LockedAmount = ""
	case "hetu.event.v1.SubnetInfo.pool_initial_tao":
		x.PoolInitialTao = ""
	case "hetu.event.v1.SubnetInfo.burned_amount":
		x.BurnedAmount = ""
	case "hetu.event.v1.SubnetInfo.created_at":
		x.CreatedAt = uint64(0)
	case "hetu.event.v1.SubnetInfo.is_active":
		x.IsActive = false
	case "hetu.event.v1.SubnetInfo.name":
		x.Name = ""
	case "hetu.event.v1.SubnetInfo.description":
		x.Description = ""
	case "hetu.event.v1.SubnetInfo.activated_at":
		x.ActivatedAt = uint64(0)
	case "hetu.event.v1.SubnetInfo.activated_block":
		x.ActivatedBlock = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.SubnetInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.SubnetInfo does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SubnetInfo) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.SubnetInfo.netuid":
		value := x.Netuid
		return protoreflect.ValueOfUint32(value)
	case "hetu.event.v1.SubnetInfo.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.SubnetInfo.alpha_token":
		value := x.AlphaToken
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.SubnetInfo.amm_pool":
		value := x.AmmPool
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.SubnetInfo.locked_amount":
		value := x.LockedAmount
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.SubnetInfo.pool_initial_tao":
		value := x.PoolInitialTao
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.SubnetInfo.burned_amount":
		value := x.BurnedAmount
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.SubnetInfo.created_at":
		value := x.CreatedAt
		return protoreflect.ValueOfUint64(value)
	case "hetu.event.v1.SubnetInfo.is_active":
		value := x.IsActive
		return protoreflect.ValueOfBool(value)
	case "hetu.event.v1.SubnetInfo.name":
		value := x.Name
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.SubnetInfo.description":
		value := x.Description
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.SubnetInfo.activated_at":
		value := x.ActivatedAt
		return protoreflect.ValueOfUint64(value)
	case "hetu.event.v1.SubnetInfo.activated_block":
		value := x.ActivatedBlock
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.SubnetInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.SubnetInfo does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SubnetInfo) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.SubnetInfo.netuid":
		x.Netuid = uint32(value.Uint())
	case "hetu.event.v1.SubnetInfo.owner":
		x.Owner = value.Interface().(string)
	case "hetu.event.v1.SubnetInfo.alpha_token":
		x.AlphaToken = value.Interface().(string)
	case "hetu.event.v1.SubnetInfo.amm_pool":
		x.AmmPool = value.Interface().(string)
	case "hetu.event.v1.SubnetInfo.locked_amount":
		x.LockedAmount = value.Interface().(string)
	case "hetu.event.v1.SubnetInfo.pool_initial_tao":
		x.PoolInitialTao = value.Interface().(string)
	case "hetu.event.v1.SubnetInfo.burned_amount":
		x.BurnedAmount = value.Interface().(string)
	case "hetu.event.v1.SubnetInfo.created_at":
		x.CreatedAt = value.Uint()
	case "hetu.event.v1.SubnetInfo.is_active":
		x.IsActive = value.Bool()
	case "hetu.event.v1.SubnetInfo.name":
		x.Name = value.Interface().(string)
	case "hetu.event.v1.SubnetInfo.description":
		x.Description = value.Interface().(string)
	case "hetu.event.v1.SubnetInfo.activated_at":
		x.ActivatedAt = value.Uint()
	case "hetu.event.v1.SubnetInfo.activated_block":
		x.ActivatedBlock = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.SubnetInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.SubnetInfo does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SubnetInfo) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.SubnetInfo.netuid":
		panic(fmt.Errorf("field netuid of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.owner":
		panic(fmt.Errorf("field owner of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.alpha_token":
		panic(fmt.Errorf("field alpha_token of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.amm_pool":
		panic(fmt.Errorf("field amm_pool of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.locked_amount":
		panic(fmt.Errorf("field locked_amount of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.pool_initial_tao":
		panic(fmt.Errorf("field pool_initial_tao of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.burned_amount":
		panic(fmt.Errorf("field burned_amount of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.created_at":
		panic(fmt.Errorf("field created_at of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.is_active":
		panic(fmt.Errorf("field is_active of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.name":
		panic(fmt.Errorf("field name of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.description":
		panic(fmt.Errorf("field description of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.activated_at":
		panic(fmt.Errorf("field activated_at of message hetu.event.v1.SubnetInfo is not mutable"))
	case "hetu.event.v1.SubnetInfo.activated_block":
		panic(fmt.Errorf("field activated_block of message hetu.event.v1.SubnetInfo is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.SubnetInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.SubnetInfo does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SubnetInfo) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.SubnetInfo.netuid":
		return protoreflect.ValueOfUint32(uint32(0))
	case "hetu.event.v1.SubnetInfo.owner":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.SubnetInfo.alpha_token":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.SubnetInfo.amm_pool":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.SubnetInfo.locked_amount":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.SubnetInfo.pool_initial_tao":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.SubnetInfo.burned_amount":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.SubnetInfo.created_at":
		return protoreflect.ValueOfUint64(uint64(0))
	case "hetu.event.v1.SubnetInfo.is_active":
		return protoreflect.ValueOfBool(false)
	case "hetu.event.v1.SubnetInfo.name":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.SubnetInfo.description":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.SubnetInfo.activated_at":
		return protoreflect.ValueOfUint64(uint64(0))
	case "hetu.event.v1.SubnetInfo.activated_block":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.SubnetInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.SubnetInfo does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SubnetInfo) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.SubnetInfo", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SubnetInfo) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SubnetInfo) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SubnetInfo) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SubnetInfo) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SubnetInfo)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Netuid != 0 {
			n += 1 + runtime.Sov(uint64(x.Netuid))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AlphaToken)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AmmPool)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LockedAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PoolInitialTao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BurnedAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CreatedAt != 0 {
			n += 1 + runtime.Sov(uint64(x.CreatedAt))
		}
		if x.IsActive {
			n += 2
		}
		l = len(x.Name)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Description)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ActivatedAt != 0 {
			n += 1 + runtime.Sov(uint64(x.ActivatedAt))
		}
		if x.ActivatedBlock != 0 {
			n += 1 + runtime.Sov(uint64(x.ActivatedBlock))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SubnetInfo)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ActivatedBlock != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ActivatedBlock))
			i--
			dAtA[i] = 0x68
		}
		if x.ActivatedAt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ActivatedAt))
			i--
			dAtA[i] = 0x60
		}
		if len(x.Description) > 0 {
			i -= len(x.Description)
			copy(dAtA[i:], x.Description)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Description)))
			i--
			dAtA[i] = 0x5a
		}
		if len(x.Name) > 0 {
			i -= len(x.Name)
			copy(dAtA[i:], x.Name)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Name)))
			i--
			dAtA[i] = 0x52
		}
		if x.IsActive {
			i--
			if x.IsActive {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x48
		}
		if x.CreatedAt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CreatedAt))
			i--
			dAtA[i] = 0x40
		}
		if len(x.BurnedAmount) > 0 {
			i -= len(x.BurnedAmount)
			copy(dAtA[i:], x.BurnedAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BurnedAmount)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.PoolInitialTao) > 0 {
			i -= len(x.PoolInitialTao)
			copy(dAtA[i:], x.PoolInitialTao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PoolInitialTao)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.LockedAmount) > 0 {
			i -= len(x.LockedAmount)
			copy(dAtA[i:], x.LockedAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LockedAmount)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.AmmPool) > 0 {
			i -= len(x.AmmPool)
			copy(dAtA[i:], x.AmmPool)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AmmPool)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AlphaToken) > 0 {
			i -= len(x.AlphaToken)
			copy(dAtA[i:], x.AlphaToken)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AlphaToken)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x12
		}
		if x.Netuid != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Netuid))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SubnetInfo)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SubnetInfo: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SubnetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Netuid", wireType)
				}
				x.Netuid = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Netuid |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AlphaToken", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AlphaToken = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AmmPool", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AmmPool = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LockedAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LockedAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolInitialTao", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PoolInitialTao = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BurnedAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BurnedAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
				}
				x.CreatedAt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CreatedAt |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.IsActive = bool(v != 0)
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Name = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Description = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 12:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ActivatedAt", wireType)
				}
				x.ActivatedAt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ActivatedAt |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 13:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ActivatedBlock", wireType)
				}
				x.ActivatedBlock = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ActivatedBlock |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_NeuronInfo                          protoreflect.MessageDescriptor
	fd_NeuronInfo_account                  protoreflect.FieldDescriptor
	fd_NeuronInfo_netuid                   protoreflect.FieldDescriptor
	fd_NeuronInfo_is_active                protoreflect.FieldDescriptor
	fd_NeuronInfo_is_validator             protoreflect.FieldDescriptor
	fd_NeuronInfo_requested_validator_role protoreflect.FieldDescriptor
	fd_NeuronInfo_stake                    protoreflect.FieldDescriptor
	fd_NeuronInfo_registration_block       protoreflect.FieldDescriptor
	fd_NeuronInfo_last_update              protoreflect.FieldDescriptor
	fd_NeuronInfo_axon_endpoint            protoreflect.FieldDescriptor
	fd_NeuronInfo_axon_port                protoreflect.FieldDescriptor
	fd_NeuronInfo_prometheus_endpoint      protoreflect.FieldDescriptor
	fd_NeuronInfo_prometheus_port          protoreflect.FieldDescriptor
)

func init() {
	file_hetu_event_v1_query_proto_init()
	md_NeuronInfo = File_hetu_event_v1_query_proto.Messages().ByName("NeuronInfo")
	fd_NeuronInfo_account = md_NeuronInfo.Fields().ByName("account")
	fd_NeuronInfo_netuid = md_NeuronInfo.Fields().ByName("netuid")
	fd_NeuronInfo_is_active = md_NeuronInfo.Fields().ByName("is_active")
	fd_NeuronInfo_is_validator = md_NeuronInfo.Fields().ByName("is_validator")
	fd_NeuronInfo_requested_validator_role = md_NeuronInfo.Fields().ByName("requested_validator_role")
	fd_NeuronInfo_stake = md_NeuronInfo.Fields().ByName("stake")
	fd_NeuronInfo_registration_block = md_NeuronInfo.Fields().ByName("registration_block")
	fd_NeuronInfo_last_update = md_NeuronInfo.Fields().ByName("last_update")
	fd_NeuronInfo_axon_endpoint = md_NeuronInfo.Fields().ByName("axon_endpoint")
	fd_NeuronInfo_axon_port = md_NeuronInfo.Fields().ByName("axon_port")
	fd_NeuronInfo_prometheus_endpoint = md_NeuronInfo.Fields().ByName("prometheus_endpoint")
	fd_NeuronInfo_prometheus_port = md_NeuronInfo.Fields().ByName("prometheus_port")
}

var _ protoreflect.Message = (*fastReflection_NeuronInfo)(nil)

type fastReflection_NeuronInfo NeuronInfo

func (x *NeuronInfo) ProtoReflect() protoreflect.Message {
	return (*fastReflection_NeuronInfo)(x)
}

func (x *NeuronInfo) slowProtoReflect() protoreflect.Message {
	mi := &file_hetu_event_v1_query_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_NeuronInfo_messageType fastReflection_NeuronInfo_messageType
var _ protoreflect.MessageType = fastReflection_NeuronInfo_messageType{}

type fastReflection_NeuronInfo_messageType struct{}

func (x fastReflection_NeuronInfo_messageType) Zero() protoreflect.Message {
	return (*fastReflection_NeuronInfo)(nil)
}
func (x fastReflection_NeuronInfo_messageType) New() protoreflect.Message {
	return new(fastReflection_NeuronInfo)
}
func (x fastReflection_NeuronInfo_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_NeuronInfo
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_NeuronInfo) Descriptor() protoreflect.MessageDescriptor {
	return md_NeuronInfo
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_NeuronInfo) Type() protoreflect.MessageType {
	return _fastReflection_NeuronInfo_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_NeuronInfo) New() protoreflect.Message {
	return new(fastReflection_NeuronInfo)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_NeuronInfo) Interface() protoreflect.ProtoMessage {
	return (*NeuronInfo)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_NeuronInfo) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Account != "" {
		value := protoreflect.ValueOfString(x.Account)
		if !f(fd_NeuronInfo_account, value) {
			return
		}
	}
	if x.Netuid != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Netuid)
		if !f(fd_NeuronInfo_netuid, value) {
			return
		}
	}
	if x.IsActive != false {
		value := protoreflect.ValueOfBool(x.IsActive)
		if !f(fd_NeuronInfo_is_active, value) {
			return
		}
	}
	if x.IsValidator != false {
		value := protoreflect.ValueOfBool(x.IsValidator)
		if !f(fd_NeuronInfo_is_validator, value) {
			return
		}
	}
	if x.RequestedValidatorRole != false {
		value := protoreflect.ValueOfBool(x.RequestedValidatorRole)
		if !f(fd_NeuronInfo_requested_validator_role, value) {
			return
		}
	}
	if x.Stake != "" {
		value := protoreflect.ValueOfString(x.Stake)
		if !f(fd_NeuronInfo_stake, value) {
			return
		}
	}
	if x.RegistrationBlock != uint64(0) {
		value := protoreflect.ValueOfUint64(x.RegistrationBlock)
		if !f(fd_NeuronInfo_registration_block, value) {
			return
		}
	}
	if x.LastUpdate != uint64(0) {
		value := protoreflect.ValueOfUint64(x.LastUpdate)
		if !f(fd_NeuronInfo_last_update, value) {
			return
		}
	}
	if x.AxonEndpoint != "" {
		value := protoreflect.ValueOfString(x.AxonEndpoint)
		if !f(fd_NeuronInfo_axon_endpoint, value) {
			return
		}
	}
	if x.AxonPort != uint32(0) {
		value := protoreflect.ValueOfUint32(x.AxonPort)
		if !f(fd_NeuronInfo_axon_port, value) {
			return
		}
	}
	if x.PrometheusEndpoint != "" {
		value := protoreflect.ValueOfString(x.PrometheusEndpoint)
		if !f(fd_NeuronInfo_prometheus_endpoint, value) {
			return
		}
	}
	if x.PrometheusPort != uint32(0) {
		value := protoreflect.ValueOfUint32(x.PrometheusPort)
		if !f(fd_NeuronInfo_prometheus_port, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_NeuronInfo) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "hetu.event.v1.NeuronInfo.account":
		return x.Account != ""
	case "hetu.event.v1.NeuronInfo.netuid":
		return x.Netuid != uint32(0)
	case "hetu.event.v1.NeuronInfo.is_active":
		return x.IsActive != false
	case "hetu.event.v1.NeuronInfo.is_validator":
		return x.IsValidator != false
	case "hetu.event.v1.NeuronInfo.requested_validator_role":
		return x.RequestedValidatorRole != false
	case "hetu.event.v1.NeuronInfo.stake":
		return x.Stake != ""
	case "hetu.event.v1.NeuronInfo.registration_block":
		return x.RegistrationBlock != uint64(0)
	case "hetu.event.v1.NeuronInfo.last_update":
		return x.LastUpdate != uint64(0)
	case "hetu.event.v1.NeuronInfo.axon_endpoint":
		return x.AxonEndpoint != ""
	case "hetu.event.v1.NeuronInfo.axon_port":
		return x.AxonPort != uint32(0)
	case "hetu.event.v1.NeuronInfo.prometheus_endpoint":
		return x.PrometheusEndpoint != ""
	case "hetu.event.v1.NeuronInfo.prometheus_port":
		return x.PrometheusPort != uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.NeuronInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.NeuronInfo does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NeuronInfo) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "hetu.event.v1.NeuronInfo.account":
		x.Account = ""
	case "hetu.event.v1.NeuronInfo.netuid":
		x.Netuid = uint32(0)
	case "hetu.event.v1.NeuronInfo.is_active":
		x.IsActive = false
	case "hetu.event.v1.NeuronInfo.is_validator":
		x.IsValidator = false
	case "hetu.event.v1.NeuronInfo.requested_validator_role":
		x.RequestedValidatorRole = false
	case "hetu.event.v1.NeuronInfo.stake":
		x.Stake = ""
	case "hetu.event.v1.NeuronInfo.registration_block":
		x.RegistrationBlock = uint64(0)
	case "hetu.event.v1.NeuronInfo.last_update":
		x.LastUpdate = uint64(0)
	case "hetu.event.v1.NeuronInfo.axon_endpoint":
		x.AxonEndpoint = ""
	case "hetu.event.v1.NeuronInfo.axon_port":
		x.AxonPort = uint32(0)
	case "hetu.event.v1.NeuronInfo.prometheus_endpoint":
		x.PrometheusEndpoint = ""
	case "hetu.event.v1.NeuronInfo.prometheus_port":
		x.PrometheusPort = uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.NeuronInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.NeuronInfo does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_NeuronInfo) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "hetu.event.v1.NeuronInfo.account":
		value := x.Account
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.NeuronInfo.netuid":
		value := x.Netuid
		return protoreflect.ValueOfUint32(value)
	case "hetu.event.v1.NeuronInfo.is_active":
		value := x.IsActive
		return protoreflect.ValueOfBool(value)
	case "hetu.event.v1.NeuronInfo.is_validator":
		value := x.IsValidator
		return protoreflect.ValueOfBool(value)
	case "hetu.event.v1.NeuronInfo.requested_validator_role":
		value := x.RequestedValidatorRole
		return protoreflect.ValueOfBool(value)
	case "hetu.event.v1.NeuronInfo.stake":
		value := x.Stake
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.NeuronInfo.registration_block":
		value := x.RegistrationBlock
		return protoreflect.ValueOfUint64(value)
	case "hetu.event.v1.NeuronInfo.last_update":
		value := x.LastUpdate
		return protoreflect.ValueOfUint64(value)
	case "hetu.event.v1.NeuronInfo.axon_endpoint":
		value := x.AxonEndpoint
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.NeuronInfo.axon_port":
		value := x.AxonPort
		return protoreflect.ValueOfUint32(value)
	case "hetu.event.v1.NeuronInfo.prometheus_endpoint":
		value := x.PrometheusEndpoint
		return protoreflect.ValueOfString(value)
	case "hetu.event.v1.NeuronInfo.prometheus_port":
		value := x.PrometheusPort
		return protoreflect.ValueOfUint32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.NeuronInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.NeuronInfo does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NeuronInfo) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "hetu.event.v1.NeuronInfo.account":
		x.Account = value.Interface().(string)
	case "hetu.event.v1.NeuronInfo.netuid":
		x.Netuid = uint32(value.Uint())
	case "hetu.event.v1.NeuronInfo.is_active":
		x.IsActive = value.Bool()
	case "hetu.event.v1.NeuronInfo.is_validator":
		x.IsValidator = value.Bool()
	case "hetu.event.v1.NeuronInfo.requested_validator_role":
		x.RequestedValidatorRole = value.Bool()
	case "hetu.event.v1.NeuronInfo.stake":
		x.Stake = value.Interface().(string)
	case "hetu.event.v1.NeuronInfo.registration_block":
		x.RegistrationBlock = value.Uint()
	case "hetu.event.v1.NeuronInfo.last_update":
		x.LastUpdate = value.Uint()
	case "hetu.event.v1.NeuronInfo.axon_endpoint":
		x.AxonEndpoint = value.Interface().(string)
	case "hetu.event.v1.NeuronInfo.axon_port":
		x.AxonPort = uint32(value.Uint())
	case "hetu.event.v1.NeuronInfo.prometheus_endpoint":
		x.PrometheusEndpoint = value.Interface().(string)
	case "hetu.event.v1.NeuronInfo.prometheus_port":
		x.PrometheusPort = uint32(value.Uint())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.NeuronInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.NeuronInfo does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NeuronInfo) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.NeuronInfo.account":
		panic(fmt.Errorf("field account of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.netuid":
		panic(fmt.Errorf("field netuid of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.is_active":
		panic(fmt.Errorf("field is_active of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.is_validator":
		panic(fmt.Errorf("field is_validator of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.requested_validator_role":
		panic(fmt.Errorf("field requested_validator_role of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.stake":
		panic(fmt.Errorf("field stake of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.registration_block":
		panic(fmt.Errorf("field registration_block of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.last_update":
		panic(fmt.Errorf("field last_update of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.axon_endpoint":
		panic(fmt.Errorf("field axon_endpoint of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.axon_port":
		panic(fmt.Errorf("field axon_port of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.prometheus_endpoint":
		panic(fmt.Errorf("field prometheus_endpoint of message hetu.event.v1.NeuronInfo is not mutable"))
	case "hetu.event.v1.NeuronInfo.prometheus_port":
		panic(fmt.Errorf("field prometheus_port of message hetu.event.v1.NeuronInfo is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.NeuronInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.NeuronInfo does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_NeuronInfo) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "hetu.event.v1.NeuronInfo.account":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.NeuronInfo.netuid":
		return protoreflect.ValueOfUint32(uint32(0))
	case "hetu.event.v1.NeuronInfo.is_active":
		return protoreflect.ValueOfBool(false)
	case "hetu.event.v1.NeuronInfo.is_validator":
		return protoreflect.ValueOfBool(false)
	case "hetu.event.v1.NeuronInfo.requested_validator_role":
		return protoreflect.ValueOfBool(false)
	case "hetu.event.v1.NeuronInfo.stake":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.NeuronInfo.registration_block":
		return protoreflect.ValueOfUint64(uint64(0))
	case "hetu.event.v1.NeuronInfo.last_update":
		return protoreflect.ValueOfUint64(uint64(0))
	case "hetu.event.v1.NeuronInfo.axon_endpoint":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.NeuronInfo.axon_port":
		return protoreflect.ValueOfUint32(uint32(0))
	case "hetu.event.v1.NeuronInfo.prometheus_endpoint":
		return protoreflect.ValueOfString("")
	case "hetu.event.v1.NeuronInfo.prometheus_port":
		return protoreflect.ValueOfUint32(uint32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: hetu.event.v1.NeuronInfo"))
		}
		panic(fmt.Errorf("message hetu.event.v1.NeuronInfo does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_NeuronInfo) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in hetu.event.v1.NeuronInfo", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_NeuronInfo) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NeuronInfo) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_NeuronInfo) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_NeuronInfo) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*NeuronInfo)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Account)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Netuid != 0 {
			n += 1 + runtime.Sov(uint64(x.Netuid))
		}
		if x.IsActive {
			n += 2
		}
		if x.IsValidator {
			n += 2
		}
		if x.RequestedValidatorRole {
			n += 2
		}
		l = len(x.Stake)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RegistrationBlock != 0 {
			n += 1 + runtime.Sov(uint64(x.RegistrationBlock))
		}
		if x.LastUpdate != 0 {
			n += 1 + runtime.Sov(uint64(x.LastUpdate))
		}
		l = len(x.AxonEndpoint)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.AxonPort != 0 {
			n += 1 + runtime.Sov(uint64(x.AxonPort))
		}
		l = len(x.PrometheusEndpoint)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PrometheusPort != 0 {
			n += 1 + runtime.Sov(uint64(x.PrometheusPort))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*NeuronInfo)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.PrometheusPort != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PrometheusPort))
			i--
			dAtA[i] = 0x60
		}
		if len(x.PrometheusEndpoint) > 0 {
			i -= len(x.PrometheusEndpoint)
			copy(dAtA[i:], x.PrometheusEndpoint)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrometheusEndpoint)))
			i--
			dAtA[i] = 0x5a
		}
		if x.AxonPort != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.AxonPort))
			i--
			dAtA[i] = 0x50
		}
		if len(x.AxonEndpoint) > 0 {
			i -= len(x.AxonEndpoint)
			copy(dAtA[i:], x.AxonEndpoint)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AxonEndpoint)))
			i--
			dAtA[i] = 0x4a
		}
		if x.LastUpdate != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.LastUpdate))
			i--
			dAtA[i] = 0x40
		}
		if x.RegistrationBlock != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.RegistrationBlock))
			i--
			dAtA[i] = 0x38
		}
		if len(x.Stake) > 0 {
			i -= len(x.Stake)
			copy(dAtA[i:], x.Stake)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Stake)))
			i--
			dAtA[i] = 0x32
		}
		if x.RequestedValidatorRole {
			i--
			if x.RequestedValidatorRole {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if x.IsValidator {
			i--
			if x.IsValidator {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x20
		}
		if x.IsActive {
			i--
			if x.IsActive {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if x.Netuid != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Netuid))
			i--
			dAtA[i] = 0x10
		}
		if len(x.Account) > 0 {
			i -= len(x.Account)
			copy(dAtA[i:], x.Account)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Account)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*NeuronInfo)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NeuronInfo: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NeuronInfo: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Account = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Netuid", wireType)
				}
				x.Netuid = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Netuid |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.IsActive = bool(v != 0)
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IsValidator", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.IsValidator = bool(v != 0)
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequestedValidatorRole", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequestedValidatorRole = bool(v != 0)
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Stake = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RegistrationBlock", wireType)
				}
				x.RegistrationBlock = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.RegistrationBlock |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
				}
				x.LastUpdate = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.LastUpdate |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AxonEndpoint", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AxonEndpoint = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AxonPort", wireType)
				}
				x.AxonPort = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.AxonPort |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrometheusEndpoint", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrometheusEndpoint = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 12:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrometheusPort", wireType)
				}
				x.PrometheusPort = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PrometheusPort |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: hetu/event/v1/query.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// QuerySubnetsRequest is the request type for the Query/Subnets RPC method
type QuerySubnetsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *QuerySubnetsRequest) Reset() {
	*x = QuerySubnetsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuerySubnetsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySubnetsRequest) ProtoMessage() {}

// Deprecated: Use QuerySubnetsRequest.ProtoReflect.Descriptor instead.
func (*QuerySubnetsRequest) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{0}
}

// QuerySubnetsResponse is the response type for the Query/Subnets RPC method
type QuerySubnetsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Subnets []*SubnetInfo `protobuf:"bytes,1,rep,name=subnets,proto3" json:"subnets,omitempty"`
}

func (x *QuerySubnetsResponse) Reset() {
	*x = QuerySubnetsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuerySubnetsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySubnetsResponse) ProtoMessage() {}

// Deprecated: Use QuerySubnetsResponse.ProtoReflect.Descriptor instead.
func (*QuerySubnetsResponse) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{1}
}

func (x *QuerySubnetsResponse) GetSubnets() []*SubnetInfo {
	if x != nil {
		return x.Subnets
	}
	return nil
}

// QuerySubnetRequest is the request type for the Query/Subnet RPC method
type QuerySubnetRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Netuid uint32 `protobuf:"varint,1,opt,name=netuid,proto3" json:"netuid,omitempty"`
}

func (x *QuerySubnetRequest) Reset() {
	*x = QuerySubnetRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuerySubnetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySubnetRequest) ProtoMessage() {}

// Deprecated: Use QuerySubnetRequest.ProtoReflect.Descriptor instead.
func (*QuerySubnetRequest) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{2}
}

func (x *QuerySubnetRequest) GetNetuid() uint32 {
	if x != nil {
		return x.Netuid
	}
	return 0
}

// QuerySubnetResponse is the response type for the Query/Subnet RPC method
type QuerySubnetResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Subnet *SubnetInfo `protobuf:"bytes,1,opt,name=subnet,proto3" json:"subnet,omitempty"`
}

func (x *QuerySubnetResponse) Reset() {
	*x = QuerySubnetResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuerySubnetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySubnetResponse) ProtoMessage() {}

// Deprecated: Use QuerySubnetResponse.ProtoReflect.Descriptor instead.
func (*QuerySubnetResponse) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{3}
}

func (x *QuerySubnetResponse) GetSubnet() *SubnetInfo {
	if x != nil {
		return x.Subnet
	}
	return nil
}

// QuerySubnetNeuronsRequest is the request type for the Query/SubnetNeurons RPC method
type QuerySubnetNeuronsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Netuid uint32 `protobuf:"varint,1,opt,name=netuid,proto3" json:"netuid,omitempty"`
}

func (x *QuerySubnetNeuronsRequest) Reset() {
	*x = QuerySubnetNeuronsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuerySubnetNeuronsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySubnetNeuronsRequest) ProtoMessage() {}

// Deprecated: Use QuerySubnetNeuronsRequest.ProtoReflect.Descriptor instead.
func (*QuerySubnetNeuronsRequest) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{4}
}

func (x *QuerySubnetNeuronsRequest) GetNetuid() uint32 {
	if x != nil {
		return x.Netuid
	}
	return 0
}

// QuerySubnetNeuronsResponse is the response type for the Query/SubnetNeurons RPC method
type QuerySubnetNeuronsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Neurons []*NeuronInfo `protobuf:"bytes,1,rep,name=neurons,proto3" json:"neurons,omitempty"`
}

func (x *QuerySubnetNeuronsResponse) Reset() {
	*x = QuerySubnetNeuronsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuerySubnetNeuronsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySubnetNeuronsResponse) ProtoMessage() {}

// Deprecated: Use QuerySubnetNeuronsResponse.ProtoReflect.Descriptor instead.
func (*QuerySubnetNeuronsResponse) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{5}
}

func (x *QuerySubnetNeuronsResponse) GetNeurons() []*NeuronInfo {
	if x != nil {
		return x.Neurons
	}
	return nil
}

// QuerySubnetPoolRequest is the request type for the Query/SubnetPool RPC method
type QuerySubnetPoolRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Netuid uint32 `protobuf:"varint,1,opt,name=netuid,proto3" json:"netuid,omitempty"`
}

func (x *QuerySubnetPoolRequest) Reset() {
	*x = QuerySubnetPoolRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuerySubnetPoolRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySubnetPoolRequest) ProtoMessage() {}

// Deprecated: Use QuerySubnetPoolRequest.ProtoReflect.Descriptor instead.
func (*QuerySubnetPoolRequest) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{6}
}

func (x *QuerySubnetPoolRequest) GetNetuid() uint32 {
	if x != nil {
		return x.Netuid
	}
	return 0
}

// QuerySubnetPoolResponse is the response type for the Query/SubnetPool RPC method
type QuerySubnetPoolResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Netuid         uint32 `protobuf:"varint,1,opt,name=netuid,proto3" json:"netuid,omitempty"`
	AmmPool        string `protobuf:"bytes,2,opt,name=amm_pool,json=ammPool,proto3" json:"amm_pool,omitempty"`
	LockedAmount   string `protobuf:"bytes,3,opt,name=locked_amount,json=lockedAmount,proto3" json:"locked_amount,omitempty"`
	BurnedAmount   string `protobuf:"bytes,4,opt,name=burned_amount,json=burnedAmount,proto3" json:"burned_amount,omitempty"`
	SubnetTaoIn    string `protobuf:"bytes,5,opt,name=subnet_tao_in,json=subnetTaoIn,proto3" json:"subnet_tao_in,omitempty"`
	SubnetAlphaIn  string `protobuf:"bytes,6,opt,name=subnet_alpha_in,json=subnetAlphaIn,proto3" json:"subnet_alpha_in,omitempty"`
	SubnetAlphaOut string `protobuf:"bytes,7,opt,name=subnet_alpha_out,json=subnetAlphaOut,proto3" json:"subnet_alpha_out,omitempty"`
}

func (x *QuerySubnetPoolResponse) Reset() {
	*x = QuerySubnetPoolResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuerySubnetPoolResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySubnetPoolResponse) ProtoMessage() {}

// Deprecated: Use QuerySubnetPoolResponse.ProtoReflect.Descriptor instead.
func (*QuerySubnetPoolResponse) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{7}
}

func (x *QuerySubnetPoolResponse) GetNetuid() uint32 {
	if x != nil {
		return x.Netuid
	}
	return 0
}

func (x *QuerySubnetPoolResponse) GetAmmPool() string {
	if x != nil {
		return x.AmmPool
	}
	return ""
}

func (x *QuerySubnetPoolResponse) GetLockedAmount() string {
	if x != nil {
		return x.LockedAmount
	}
	return ""
}

func (x *QuerySubnetPoolResponse) GetBurnedAmount() string {
	if x != nil {
		return x.BurnedAmount
	}
	return ""
}

func (x *QuerySubnetPoolResponse) GetSubnetTaoIn() string {
	if x != nil {
		return x.SubnetTaoIn
	}
	return ""
}

func (x *QuerySubnetPoolResponse) GetSubnetAlphaIn() string {
	if x != nil {
		return x.SubnetAlphaIn
	}
	return ""
}

func (x *QuerySubnetPoolResponse) GetSubnetAlphaOut() string {
	if x != nil {
		return x.SubnetAlphaOut
	}
	return ""
}

// QueryValidatorWeightsRequest is the request type for the Query/ValidatorWeights RPC method
type QueryValidatorWeightsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Netuid    uint32 `protobuf:"varint,1,opt,name=netuid,proto3" json:"netuid,omitempty"`
	Validator string `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
}

func (x *QueryValidatorWeightsRequest) Reset() {
	*x = QueryValidatorWeightsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueryValidatorWeightsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryValidatorWeightsRequest) ProtoMessage() {}

// Deprecated: Use QueryValidatorWeightsRequest.ProtoReflect.Descriptor instead.
func (*QueryValidatorWeightsRequest) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{8}
}

func (x *QueryValidatorWeightsRequest) GetNetuid() uint32 {
	if x != nil {
		return x.Netuid
	}
	return 0
}

func (x *QueryValidatorWeightsRequest) GetValidator() string {
	if x != nil {
		return x.Validator
	}
	return ""
}

// QueryValidatorWeightsResponse is the response type for the Query/ValidatorWeights RPC method
type QueryValidatorWeightsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Netuid    uint32   `protobuf:"varint,1,opt,name=netuid,proto3" json:"netuid,omitempty"`
	Validator string   `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	Weights   []string `protobuf:"bytes,3,rep,name=weights,proto3" json:"weights,omitempty"`
}

func (x *QueryValidatorWeightsResponse) Reset() {
	*x = QueryValidatorWeightsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueryValidatorWeightsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryValidatorWeightsResponse) ProtoMessage() {}

// Deprecated: Use QueryValidatorWeightsResponse.ProtoReflect.Descriptor instead.
func (*QueryValidatorWeightsResponse) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{9}
}

func (x *QueryValidatorWeightsResponse) GetNetuid() uint32 {
	if x != nil {
		return x.Netuid
	}
	return 0
}

func (x *QueryValidatorWeightsResponse) GetValidator() string {
	if x != nil {
		return x.Validator
	}
	return ""
}

func (x *QueryValidatorWeightsResponse) GetWeights() []string {
	if x != nil {
		return x.Weights
	}
	return nil
}

// SubnetInfo represents subnet information
type SubnetInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Netuid         uint32 `protobuf:"varint,1,opt,name=netuid,proto3" json:"netuid,omitempty"`
	Owner          string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	AlphaToken     string `protobuf:"bytes,3,opt,name=alpha_token,json=alphaToken,proto3" json:"alpha_token,omitempty"`
	AmmPool        string `protobuf:"bytes,4,opt,name=amm_pool,json=ammPool,proto3" json:"amm_pool,omitempty"`
	LockedAmount   string `protobuf:"bytes,5,opt,name=locked_amount,json=lockedAmount,proto3" json:"locked_amount,omitempty"`
	PoolInitialTao string `protobuf:"bytes,6,opt,name=pool_initial_tao,json=poolInitialTao,proto3" json:"pool_initial_tao,omitempty"`
	BurnedAmount   string `protobuf:"bytes,7,opt,name=burned_amount,json=burnedAmount,proto3" json:"burned_amount,omitempty"`
	CreatedAt      uint64 `protobuf:"varint,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	IsActive       bool   `protobuf:"varint,9,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	Name           string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	Description    string `protobuf:"bytes,11,opt,name=description,proto3" json:"description,omitempty"`
	ActivatedAt    uint64 `protobuf:"varint,12,opt,name=activated_at,json=activatedAt,proto3" json:"activated_at,omitempty"`
	ActivatedBlock uint64 `protobuf:"varint,13,opt,name=activated_block,json=activatedBlock,proto3" json:"activated_block,omitempty"`
}

func (x *SubnetInfo) Reset() {
	*x = SubnetInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SubnetInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubnetInfo) ProtoMessage() {}

// Deprecated: Use SubnetInfo.ProtoReflect.Descriptor instead.
func (*SubnetInfo) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{10}
}

func (x *SubnetInfo) GetNetuid() uint32 {
	if x != nil {
		return x.Netuid
	}
	return 0
}

func (x *SubnetInfo) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *SubnetInfo) GetAlphaToken() string {
	if x != nil {
		return x.AlphaToken
	}
	return ""
}

func (x *SubnetInfo) GetAmmPool() string {
	if x != nil {
		return x.AmmPool
	}
	return ""
}

func (x *SubnetInfo) GetLockedAmount() string {
	if x != nil {
		return x.LockedAmount
	}
	return ""
}

func (x *SubnetInfo) GetPoolInitialTao() string {
	if x != nil {
		return x.PoolInitialTao
	}
	return ""
}

func (x *SubnetInfo) GetBurnedAmount() string {
	if x != nil {
		return x.BurnedAmount
	}
	return ""
}

func (x *SubnetInfo) GetCreatedAt() uint64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *SubnetInfo) GetIsActive() bool {
	if x != nil {
		return x.IsActive
	}
	return false
}

func (x *SubnetInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *SubnetInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *SubnetInfo) GetActivatedAt() uint64 {
	if x != nil {
		return x.ActivatedAt
	}
	return 0
}

func (x *SubnetInfo) GetActivatedBlock() uint64 {
	if x != nil {
		return x.ActivatedBlock
	}
	return 0
}

// NeuronInfo represents neuron information
type NeuronInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Account                string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	Netuid                 uint32 `protobuf:"varint,2,opt,name=netuid,proto3" json:"netuid,omitempty"`
	IsActive               bool   `protobuf:"varint,3,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	IsValidator            bool   `protobuf:"varint,4,opt,name=is_validator,json=isValidator,proto3" json:"is_validator,omitempty"`
	RequestedValidatorRole bool   `protobuf:"varint,5,opt,name=requested_validator_role,json=requestedValidatorRole,proto3" json:"requested_validator_role,omitempty"`
	Stake                  string `protobuf:"bytes,6,opt,name=stake,proto3" json:"stake,omitempty"`
	RegistrationBlock      uint64 `protobuf:"varint,7,opt,name=registration_block,json=registrationBlock,proto3" json:"registration_block,omitempty"`
	LastUpdate             uint64 `protobuf:"varint,8,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	AxonEndpoint           string `protobuf:"bytes,9,opt,name=axon_endpoint,json=axonEndpoint,proto3" json:"axon_endpoint,omitempty"`
	AxonPort               uint32 `protobuf:"varint,10,opt,name=axon_port,json=axonPort,proto3" json:"axon_port,omitempty"`
	PrometheusEndpoint     string `protobuf:"bytes,11,opt,name=prometheus_endpoint,json=prometheusEndpoint,proto3" json:"prometheus_endpoint,omitempty"`
	PrometheusPort         uint32 `protobuf:"varint,12,opt,name=prometheus_port,json=prometheusPort,proto3" json:"prometheus_port,omitempty"`
}

func (x *NeuronInfo) Reset() {
	*x = NeuronInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_hetu_event_v1_query_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NeuronInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NeuronInfo) ProtoMessage() {}

// Deprecated: Use NeuronInfo.ProtoReflect.Descriptor instead.
func (*NeuronInfo) Descriptor() ([]byte, []int) {
	return file_hetu_event_v1_query_proto_rawDescGZIP(), []int{11}
}

func (x *NeuronInfo) GetAccount() string {
	if x != nil {
		return x.Account
	}
	return ""
}

func (x *NeuronInfo) GetNetuid() uint32 {
	if x != nil {
		return x.Netuid
	}
	return 0
}

func (x *NeuronInfo) GetIsActive() bool {
	if x != nil {
		return x.IsActive
	}
	return false
}

func (x *NeuronInfo) GetIsValidator() bool {
	if x != nil {
		return x.IsValidator
	}
	return false
}

func (x *NeuronInfo) GetRequestedValidatorRole() bool {
	if x != nil {
		return x.RequestedValidatorRole
	}
	return false
}

func (x *NeuronInfo) GetStake() string {
	if x != nil {
		return x.Stake
	}
	return ""
}

func (x *NeuronInfo) GetRegistrationBlock() uint64 {
	if x != nil {
		return x.RegistrationBlock
	}
	return 0
}

func (x *NeuronInfo) GetLastUpdate() uint64 {
	if x != nil {
		return x.LastUpdate
	}
	return 0
}

func (x *NeuronInfo) GetAxonEndpoint() string {
	if x != nil {
		return x.AxonEndpoint
	}
	return ""
}

func (x *NeuronInfo) GetAxonPort() uint32 {
	if x != nil {
		return x.AxonPort
	}
	return 0
}

func (x *NeuronInfo) GetPrometheusEndpoint() string {
	if x != nil {
		return x.PrometheusEndpoint
	}
	return ""
}

func (x *NeuronInfo) GetPrometheusPort() uint32 {
	if x != nil {
		return x.PrometheusPort
	}
	return 0
}

var File_hetu_event_v1_query_proto protoreflect.FileDescriptor

var file_hetu_event_v1_query_proto_rawDesc = []byte{
	0x0a, 0x19, 0x68, 0x65, 0x74, 0x75, 0x2f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2f, 0x76, 0x31, 0x2f,
	0x71, 0x75, 0x65, 0x72, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x68, 0x65, 0x74,
	0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x1a, 0x14, 0x67, 0x6f, 0x67, 0x6f,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x61, 0x6e, 0x6e,
	0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x15,
	0x0a, 0x13, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x73, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x51, 0x0a, 0x14, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53, 0x75,
	0x62, 0x6e, 0x65, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x39, 0x0a,
	0x07, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19,
	0x2e, 0x68, 0x65, 0x74, 0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x53,
	0x75, 0x62, 0x6e, 0x65, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52,
	0x07, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x73, 0x22, 0x2c, 0x0a, 0x12, 0x51, 0x75, 0x65, 0x72,
	0x79, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16,
	0x0a, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06,
	0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x22, 0x4e, 0x0a, 0x13, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53,
	0x75, 0x62, 0x6e, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x37, 0x0a,
	0x06, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e,
	0x68, 0x65, 0x74, 0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x75,
	0x62, 0x6e, 0x65, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x06,
	0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x22, 0x33, 0x0a, 0x19, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53,
	0x75, 0x62, 0x6e, 0x65, 0x74, 0x4e, 0x65, 0x75, 0x72, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x22, 0x57, 0x0a, 0x1a, 0x51,
	0x75, 0x65, 0x72, 0x79, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x4e, 0x65, 0x75, 0x72, 0x6f, 0x6e,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x39, 0x0a, 0x07, 0x6e, 0x65, 0x75,
	0x72, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x68, 0x65, 0x74,
	0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x65, 0x75, 0x72, 0x6f,
	0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x07, 0x6e, 0x65, 0x75,
	0x72, 0x6f, 0x6e, 0x73, 0x22, 0x30, 0x0a, 0x16, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53, 0x75, 0x62,
	0x6e, 0x65, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16,
	0x0a, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06,
	0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x22, 0x8c, 0x02, 0x0a, 0x17, 0x51, 0x75, 0x65, 0x72, 0x79,
	0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x61, 0x6d,
	0x6d, 0x5f, 0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x6d,
	0x6d, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x23, 0x0a, 0x0d, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x5f,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x6c, 0x6f,
	0x63, 0x6b, 0x65, 0x64, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x62, 0x75,
	0x72, 0x6e, 0x65, 0x64, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0c, 0x62, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12,
	0x22, 0x0a, 0x0d, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x61, 0x6f, 0x5f, 0x69, 0x6e,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x54, 0x61,
	0x6f, 0x49, 0x6e, 0x12, 0x26, 0x0a, 0x0f, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x5f, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x5f, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x73, 0x75,
	0x62, 0x6e, 0x65, 0x74, 0x41, 0x6c, 0x70, 0x68, 0x61, 0x49, 0x6e, 0x12, 0x28, 0x0a, 0x10, 0x73,
	0x75, 0x62, 0x6e, 0x65, 0x74, 0x5f, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x5f, 0x6f, 0x75, 0x74, 0x18,
	0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x41, 0x6c, 0x70,
	0x68, 0x61, 0x4f, 0x75, 0x74, 0x22, 0x54, 0x0a, 0x1c, 0x51, 0x75, 0x65, 0x72, 0x79, 0x56, 0x61,
	0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x73, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x12, 0x1c, 0x0a,
	0x09, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x09, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x22, 0x6f, 0x0a, 0x1d, 0x51,
	0x75, 0x65, 0x72, 0x79, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x57, 0x65, 0x69,
	0x67, 0x68, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06,
	0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6e, 0x65,
	0x74, 0x75, 0x69, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f,
	0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74,
	0x6f, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x73, 0x18, 0x03, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x07, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x73, 0x22, 0xa8, 0x03, 0x0a,
	0x0a, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x16, 0x0a, 0x06, 0x6e,
	0x65, 0x74, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6e, 0x65, 0x74,
	0x75, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x19, 0x0a, 0x08, 0x61, 0x6d,
	0x6d, 0x5f, 0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x6d,
	0x6d, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x23, 0x0a, 0x0d, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x5f,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x6c, 0x6f,
	0x63, 0x6b, 0x65, 0x64, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x28, 0x0a, 0x10, 0x70, 0x6f,
	0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x74, 0x61, 0x6f, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x70, 0x6f, 0x6f, 0x6c, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61,
	0x6c, 0x54, 0x61, 0x6f, 0x12, 0x23, 0x0a, 0x0d, 0x62, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x5f, 0x61,
	0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x62, 0x75, 0x72,
	0x6e, 0x65, 0x64, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x63,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x61,
	0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x41,
	0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x0a, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,
	0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
	0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x61,
	0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x0c, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x0b, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x27,
	0x0a, 0x0f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x6c, 0x6f, 0x63,
	0x6b, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0e, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74,
	0x65, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x22, 0xba, 0x03, 0x0a, 0x0a, 0x4e, 0x65, 0x75, 0x72,
	0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e,
	0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x12, 0x16, 0x0a, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x06, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x61,
	0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x41,
	0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x73, 0x5f, 0x76, 0x61, 0x6c, 0x69,
	0x64, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x73, 0x56,
	0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x38, 0x0a, 0x18, 0x72, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x65, 0x64, 0x5f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x5f,
	0x72, 0x6f, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x16, 0x72, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x52, 0x6f,
	0x6c, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x6b, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x73, 0x74, 0x61, 0x6b, 0x65, 0x12, 0x2d, 0x0a, 0x12, 0x72, 0x65, 0x67, 0x69,
	0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x11, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x61, 0x73, 0x74, 0x5f,
	0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x6c, 0x61,
	0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x78, 0x6f, 0x6e,
	0x5f, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0c, 0x61, 0x78, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x1b, 0x0a,
	0x09, 0x61, 0x78, 0x6f, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x08, 0x61, 0x78, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x2f, 0x0a, 0x13, 0x70, 0x72,
	0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e,
	0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68,
	0x65, 0x75, 0x73, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x27, 0x0a, 0x0f, 0x70,
	0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x0c,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73,
	0x50, 0x6f, 0x72, 0x74, 0x32, 0xcc, 0x05, 0x0a, 0x05, 0x51, 0x75, 0x65, 0x72, 0x79, 0x12, 0x72,
	0x0a, 0x07, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x73, 0x12, 0x22, 0x2e, 0x68, 0x65, 0x74, 0x75,
	0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53,
	0x75, 0x62, 0x6e, 0x65, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e,
	0x68, 0x65, 0x74, 0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75,
	0x65, 0x72, 0x79, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x1e, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x18, 0x12, 0x16, 0x2f, 0x68, 0x65, 0x74,
	0x75, 0x2f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x73, 0x75, 0x62, 0x6e, 0x65,
	0x74, 0x73, 0x12, 0x77, 0x0a, 0x06, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x12, 0x21, 0x2e, 0x68,
	0x65, 0x74, 0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65,
	0x72, 0x79, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x22, 0x2e, 0x68, 0x65, 0x74, 0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e,
	0x51, 0x75, 0x65, 0x72, 0x79, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0x26, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x20, 0x12, 0x1e, 0x2f, 0x68, 0x65,
	0x74, 0x75, 0x2f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x73, 0x75, 0x62, 0x6e,
	0x65, 0x74, 0x2f, 0x7b, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x7d, 0x12, 0x94, 0x01, 0x0a, 0x0d,
	0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x4e, 0x65, 0x75, 0x72, 0x6f, 0x6e, 0x73, 0x12, 0x28, 0x2e,
	0x68, 0x65, 0x74, 0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75,
	0x65, 0x72, 0x79, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x4e, 0x65, 0x75, 0x72, 0x6f, 0x6e, 0x73,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x29, 0x2e, 0x68, 0x65, 0x74, 0x75, 0x2e, 0x65,
	0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53, 0x75, 0x62,
	0x6e, 0x65, 0x74, 0x4e, 0x65, 0x75, 0x72, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x2e, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x28, 0x12, 0x26, 0x2f, 0x68, 0x65, 0x74,
	0x75, 0x2f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x73, 0x75, 0x62, 0x6e, 0x65,
	0x74, 0x2f, 0x7b, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x7d, 0x2f, 0x6e, 0x65, 0x75, 0x72, 0x6f,
	0x6e, 0x73, 0x12, 0x88, 0x01, 0x0a, 0x0a, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x50, 0x6f, 0x6f,
	0x6c, 0x12, 0x25, 0x2e, 0x68, 0x65, 0x74, 0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76,
	0x31, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x50, 0x6f, 0x6f,
	0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x68, 0x65, 0x74, 0x75, 0x2e,
	0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53, 0x75,
	0x62, 0x6e, 0x65, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x2b, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x25, 0x12, 0x23, 0x2f, 0x68, 0x65, 0x74, 0x75, 0x2f,
	0x65, 0x76, 0x65, 0x6e, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x2f,
	0x7b, 0x6e, 0x65, 0x74, 0x75, 0x69, 0x64, 0x7d, 0x2f, 0x70, 0x6f, 0x6f, 0x6c, 0x12, 0xb3, 0x01,
	0x0a, 0x10, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x57, 0x65, 0x69, 0x67, 0x68,
	0x74, 0x73, 0x12, 0x2b, 0x2e, 0x68, 0x65, 0x74, 0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e,
	0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f,
	0x72, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x2c, 0x2e, 0x68, 0x65, 0x74, 0x75, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x2e,
	0x51, 0x75, 0x65, 0x72, 0x79, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x57, 0x65,
	0x69, 0x67, 0x68, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x44, 0x82,
	0xd3, 0xe4, 0x93, 0x02, 0x3e, 0x12, 0x3c, 0x2f, 0x68, 0x65, 0x74, 0x75, 0x2f, 0x65, 0x76, 0x65,
	0x6e, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x2f, 0x7b, 0x6e, 0x65,
	0x74, 0x75, 0x69, 0x64, 0x7d, 0x2f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x2f,
	0x7b, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x7d, 0x2f, 0x77, 0x65, 0x69, 0x67,
	0x68, 0x74, 0x73, 0x42, 0x9d, 0x01, 0x0a, 0x11, 0x63, 0x6f, 0x6d, 0x2e, 0x68, 0x65, 0x74, 0x75,
	0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x31, 0x42, 0x0a, 0x51, 0x75, 0x65, 0x72, 0x79,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x26, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x68, 0x65, 0x74, 0x75, 0x2f, 0x65,
	0x76, 0x65, 0x6e, 0x74, 0x2f, 0x76, 0x31, 0x3b, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x76, 0x31, 0xa2,
	0x02, 0x03, 0x48, 0x45, 0x58, 0xaa, 0x02, 0x0d, 0x48, 0x65, 0x74, 0x75, 0x2e, 0x45, 0x76, 0x65,
	0x6e, 0x74, 0x2e, 0x56, 0x31, 0xca, 0x02, 0x0d, 0x48, 0x65, 0x74, 0x75, 0x5c, 0x45, 0x76, 0x65,
	0x6e, 0x74, 0x5c, 0x56, 0x31, 0xe2, 0x02, 0x19, 0x48, 0x65, 0x74, 0x75, 0x5c, 0x45, 0x76, 0x65,
	0x6e, 0x74, 0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
	0x61, 0xea, 0x02, 0x0f, 0x48, 0x65, 0x74, 0x75, 0x3a, 0x3a, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x3a,
	0x3a, 0x56, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_hetu_event_v1_query_proto_rawDescOnce sync.Once
	file_hetu_event_v1_query_proto_rawDescData = file_hetu_event_v1_query_proto_rawDesc
)

func file_hetu_event_v1_query_proto_rawDescGZIP() []byte {
	file_hetu_event_v1_query_proto_rawDescOnce.Do(func() {
		file_hetu_event_v1_query_proto_rawDescData = protoimpl.X.CompressGZIP(file_hetu_event_v1_query_proto_rawDescData)
	})
	return file_hetu_event_v1_query_proto_rawDescData
}

var file_hetu_event_v1_query_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_hetu_event_v1_query_proto_goTypes = []interface{}{
	(*QuerySubnetsRequest)(nil),           // 0: hetu.event.v1.QuerySubnetsRequest
	(*QuerySubnetsResponse)(nil),          // 1: hetu.event.v1.QuerySubnetsResponse
	(*QuerySubnetRequest)(nil),            // 2: hetu.event.v1.QuerySubnetRequest
	(*QuerySubnetResponse)(nil),           // 3: hetu.event.v1.QuerySubnetResponse
	(*QuerySubnetNeuronsRequest)(nil),     // 4: hetu.event.v1.QuerySubnetNeuronsRequest
	(*QuerySubnetNeuronsResponse)(nil),    // 5: hetu.event.v1.QuerySubnetNeuronsResponse
	(*QuerySubnetPoolRequest)(nil),        // 6: hetu.event.v1.QuerySubnetPoolRequest
	(*QuerySubnetPoolResponse)(nil),       // 7: hetu.event.v1.QuerySubnetPoolResponse
	(*QueryValidatorWeightsRequest)(nil),  // 8: hetu.event.v1.QueryValidatorWeightsRequest
	(*QueryValidatorWeightsResponse)(nil), // 9: hetu.event.v1.QueryValidatorWeightsResponse
	(*SubnetInfo)(nil),                    // 10: hetu.event.v1.SubnetInfo
	(*NeuronInfo)(nil),                    // 11: hetu.event.v1.NeuronInfo
}
var file_hetu_event_v1_query_proto_depIdxs = []int32{
	10, // 0: hetu.event.v1.QuerySubnetsResponse.subnets:type_name -> hetu.event.v1.SubnetInfo
	10, // 1: hetu.event.v1.QuerySubnetResponse.subnet:type_name -> hetu.event.v1.SubnetInfo
	11, // 2: hetu.event.v1.QuerySubnetNeuronsResponse.neurons:type_name -> hetu.event.v1.NeuronInfo
	0,  // 3: hetu.event.v1.Query.Subnets:input_type -> hetu.event.v1.QuerySubnetsRequest
	2,  // 4: hetu.event.v1.Query.Subnet:input_type -> hetu.event.v1.QuerySubnetRequest
	4,  // 5: hetu.event.v1.Query.SubnetNeurons:input_type -> hetu.event.v1.QuerySubnetNeuronsRequest
	6,  // 6: hetu.event.v1.Query.SubnetPool:input_type -> hetu.event.v1.QuerySubnetPoolRequest
	8,  // 7: hetu.event.v1.Query.ValidatorWeights:input_type -> hetu.event.v1.QueryValidatorWeightsRequest
	1,  // 8: hetu.event.v1.Query.Subnets:output_type -> hetu.event.v1.QuerySubnetsResponse
	3,  // 9: hetu.event.v1.Query.Subnet:output_type -> hetu.event.v1.QuerySubnetResponse
	5,  // 10: hetu.event.v1.Query.SubnetNeurons:output_type -> hetu.event.v1.QuerySubnetNeuronsResponse
	7,  // 11: hetu.event.v1.Query.SubnetPool:output_type -> hetu.event.v1.QuerySubnetPoolResponse
	9,  // 12: hetu.event.v1.Query.ValidatorWeights:output_type -> hetu.event.v1.QueryValidatorWeightsResponse
	8,  // [8:13] is the sub-list for method output_type
	3,  // [3:8] is the sub-list for method input_type
	3,  // [3:3] is the sub-list for extension type_name
	3,  // [3:3] is the sub-list for extension extendee
	0,  // [0:3] is the sub-list for field type_name
}

func init() { file_hetu_event_v1_query_proto_init() }
func file_hetu_event_v1_query_proto_init() {
	if File_hetu_event_v1_query_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_hetu_event_v1_query_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuerySubnetsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuerySubnetsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuerySubnetRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuerySubnetResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuerySubnetNeuronsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuerySubnetNeuronsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuerySubnetPoolRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuerySubnetPoolResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueryValidatorWeightsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueryValidatorWeightsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SubnetInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_hetu_event_v1_query_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NeuronInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_hetu_event_v1_query_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_hetu_event_v1_query_proto_goTypes,
		DependencyIndexes: file_hetu_event_v1_query_proto_depIdxs,
		MessageInfos:      file_hetu_event_v1_query_proto_msgTypes,
	}.Build()
	File_hetu_event_v1_query_proto = out.File
	file_hetu_event_v1_query_proto_rawDesc = nil
	file_hetu_event_v1_query_proto_goTypes = nil
	file_hetu_event_v1_query_proto_depIdxs = nil
}
